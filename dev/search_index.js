var documenterSearchIndex = {"docs":
[{"location":"EasyModels/#Easy-NODE-and-UDE","page":"Easy NODE and UDE","title":"Easy NODE and UDE","text":"","category":"section"},{"location":"EasyModels/","page":"Easy NODE and UDE","title":"Easy NODE and UDE","text":"EasyNODE and EasyUDE provide a quick, simple alternative to the other model constructors featured by UniversalDiffEq.jl. They each return pre-trained models, in which neural networks are kept to 1 hidden layer. The models are trained using the gradient_descent! function.","category":"page"},{"location":"EasyModels/#EasyNODE-constructors:","page":"Easy NODE and UDE","title":"EasyNODE constructors:","text":"","category":"section"},{"location":"EasyModels/","page":"Easy NODE and UDE","title":"Easy NODE and UDE","text":"EasyNODE(data,X;kwargs ... )\nEasyNODE(data;kwargs ... )","category":"page"},{"location":"EasyModels/#UniversalDiffEq.EasyNODE-Tuple{Any, Any}-EasyModels","page":"Easy NODE and UDE","title":"UniversalDiffEq.EasyNODE","text":"EasyNODE(data,X;kwargs ... )\n\nWhen a dataframe X is supplied the model will run with covariates. the argument X should have a column for time t with the value for time in the remaining columns. The values in X will be interpolated with a linear spline for values of time not included in the data frame. \n\nkwargs\n\ntime_column_name: Name of column in data that corresponds to time. Default is \"time\".  \nvariable_column_name: Name of column in data that corresponds to the variables. Default is \"variable\".\nvalue_column_name: Name of column in data that corresponds to the covariates. Default is \"value\".  \nhidden_units: Number of neurons in hidden layer. Default is 10.\nseed: Fixed random seed for repeatable results. Default is 1.\nproc_weight: Weight of process error omega_{proc}. Default is 1.0.\nobs_weight: Weight of observation error omega_{obs}. Default is 1.0.\nreg_weight: Weight of regularization error omega_{reg}. Default is 10^-6.\nreg_type: Type of regularization, whether \"L1\" or \"L2\" regularization. Default is \"L2\".\nl: Extrapolation parameter for forecasting. Default is 0.25.\nextrap_rho: Extrapolation parameter for forecasting. Default is 0.0.\nstep_size: Step size for ADAM optimizer. Default is 0.05.\nmaxiter: Maximum number of iterations in gradient descent algorithm. Default is 500.\nverbose: Should the training loss values be printed?. Default is false.\n\n\n\n\n\n","category":"method"},{"location":"EasyModels/#UniversalDiffEq.EasyNODE-Tuple{Any}-EasyModels","page":"Easy NODE and UDE","title":"UniversalDiffEq.EasyNODE","text":"EasyNODE(data;kwargs ... )\n\nConstructs a pretrained continuous time model for the data set data using a single layer neural network to represent the systems dynamics. \n\nkwargs\n\ntime_column_name: Name of column in data that corresponds to time. Default is \"time\".  \nhidden_units: Number of neurons in hidden layer. Default is 10.\nseed: Fixed random seed for repeatable results. Default is 1.\nproc_weight: Weight of process error omega_{proc}. Default is 1.0.\nobs_weight: Weight of observation error omega_{obs}. Default is 1.0.\nreg_weight: Weight of regularization error omega_{reg}. Default is 10^-6.\nreg_type: Type of regularization, whether \"L1\" or \"L2\" regularization. Default is \"L2\".\nl: Extrapolation parameter for forecasting. Default is 0.25.\nextrap_rho: Extrapolation parameter for forecasting. Default is 0.0.\nstep_size: Step size for ADAM optimizer. Default is 0.05.\nmaxiter: Maximum number of iterations in gradient descent algorithm. Default is 500.\nverbose: Should the training loss values be printed?. Default is false.\n\n\n\n\n\n","category":"method"},{"location":"EasyModels/","page":"Easy NODE and UDE","title":"Easy NODE and UDE","text":"Creating an UDE constructor using the EasyNODE function is equivalent to creating it using the NODE function and running gradient_descent!.","category":"page"},{"location":"EasyModels/","page":"Easy NODE and UDE","title":"Easy NODE and UDE","text":"easy_model = EasyNODE(data)\n\n#Is equivalent to running\nmodel = NODE(data)\ngradient_descent!(model)","category":"page"},{"location":"EasyModels/#EasyUDE-constructors:","page":"Easy NODE and UDE","title":"EasyUDE constructors:","text":"","category":"section"},{"location":"EasyModels/","page":"Easy NODE and UDE","title":"Easy NODE and UDE","text":"EasyUDE(data,known_dynamics!,initial_parameters;kwargs ... )\nEasyUDE(data::DataFrame,X,known_dynamics!::Function,initial_parameters;kwargs ... )","category":"page"},{"location":"EasyModels/#UniversalDiffEq.EasyUDE-Tuple{Any, Any, Any}-EasyModels","page":"Easy NODE and UDE","title":"UniversalDiffEq.EasyUDE","text":"EasyUDE(data,derivs!,initial_parameters;kwargs ... )\n\nConstructs a pretrained UDE model for the data set data  based on user defined derivatives derivs. An initial guess of model parameters are supplied with the initial_parameters argument. \n\nkwargs\n\ntime_column_name: Name of column in data that corresponds to time. Default is \"time\".\nhidden_units: Number of neurons in hidden layer. Default is 10.\nseed: Fixed random seed for repeatable results. Default is 1.\nproc_weight: Weight of process error omega_{proc}. Default is 1.0.\nobs_weight: Weight of observation error omega_{obs}. Default is 1.0.\nreg_weight: Weight of regularization error omega_{reg}. Default is 10^-6.\nreg_type: Type of regularization, whether \"L1\" or \"L2\" regularization. Default is \"L2\".\nl: Extrapolation parameter for forecasting. Default is 0.25.\nextrap_rho: Extrapolation parameter for forecasting. Default is 0.0.\nstep_size: Step size for ADAM optimizer. Default is 0.05.\nmaxiter: Maximum number of iterations in gradient descent algorithm. Default is 500.\nverbose: Should the training loss values be printed?. Default is false.\n\n\n\n\n\n","category":"method"},{"location":"EasyModels/#UniversalDiffEq.EasyUDE-Tuple{DataFrame, Any, Function, Any}-EasyModels","page":"Easy NODE and UDE","title":"UniversalDiffEq.EasyUDE","text":"EasyUDE(data::DataFrame,X,derivs!::Function,initial_parameters;kwargs ... )\n\nWhen a dataframe X is supplied the model will run with covariates. the argument X should have a column for time t with the value for time in the remaining columns. The values in X will be interpolated with a linear spline for value of time not included in the data frame.  When X is provided the derivs function must have the form derivs!(du,u,x,p,t) where x is a vector with the value of the covariates at time t. \n\n# kwargs\n\ntime_column_name: Name of column in data that corresponds to time. Default is \"time\".  \nvariable_column_name: Name of column in data that corresponds to the variables. Default is \"variable\".\nvalue_column_name: Name of column in data that corresponds to the covariates. Default is \"value\".  \nhidden_units: Number of neurons in hidden layer. Default is 10.\nseed: Fixed random seed for repeatable results. Default is 1.\nproc_weight: Weight of process error omega_{proc}. Default is 1.0.\nobs_weight: Weight of observation error omega_{obs}. Default is 1.0.\nreg_weight: Weight of regularization error omega_{reg}. Default is 10^-6.\nreg_type: Type of regularization, whether \"L1\" or \"L2\" regularization. Default is \"L2\".\nl: Extrapolation parameter for forecasting. Default is 0.25.\nextrap_rho: Extrapolation parameter for forecasting. Default is 0.0.\nstep_size: Step size for ADAM optimizer. Default is 0.05.\nmaxiter: Maximum number of iterations in gradient descent algorithm. Default is 500.\nverbose: Should the training loss values be printed?. Default is false.\n\n\n\n\n\n","category":"method"},{"location":"EasyModels/","page":"Easy NODE and UDE","title":"Easy NODE and UDE","text":"Unlike EasyNODE, running EasyUDE is not equivalent to running CustomDerivatives and gradient_descent!. EasyUDE creates UDE constructors with a continuous process model of the form","category":"page"},{"location":"EasyModels/","page":"Easy NODE and UDE","title":"Easy NODE and UDE","text":"fracdxdt = NN(xwb) + f(xa)","category":"page"},{"location":"EasyModels/","page":"Easy NODE and UDE","title":"Easy NODE and UDE","text":"where f corresponds to the known_dynamics! argument, and a the initial_parameters argument in EasyUDE.","category":"page"},{"location":"EasyModels/","page":"Easy NODE and UDE","title":"Easy NODE and UDE","text":"function known_dynamics!(du,u,parameters,t)\n    du .= parameters.a.*u .+ parameters.b #some function here\n    return du\nend\ninitial_parameters = (a = 1, b = 0.1)\neasy_model = EasyUDE(data,known_dynamics!,initial_parameters)\n\n#Is equivalent to running\nusing Lux, Random\ndims_in = 1\nhidden_units = 10\nnonlinearity = tanh\ndims_out = 1\nNN = Lux.Chain(Lux.Dense(dims_in,hidden_units,nonlinearity),\n                Lux.Dense(hidden_units,dims_out))\n\nrng = Random.default_rng() \nNNparameters, states = Lux.setup(rng,NN) \n\nfunction derivs!\n    C, states = NN(u,p.NN,states)\n    du .= C .+ a*u .+ b\n    return du\nend\ninitial_parameters = (a = 1, b = 0.1)\nmodel = CustomDerivatives(data,derivs!,initial_parameters)","category":"page"},{"location":"NutsAndBolts/#UDE-model-construction","page":"UDE model construction","title":"UDE model construction","text":"","category":"section"},{"location":"NutsAndBolts/","page":"UDE model construction","title":"UDE model construction","text":"Some users may wish to access elements of a fitted model directly to create custom model visualizations, performance tests, or other applications not foreseen by the developers. To this end, we provide documentation of classes (Julia mutable structs) used by UniversalDiffEq.jl to build the NODE and UDE objects. The package is built around the UDE class which stores the data used to fit a model and instances of six submodel classes used to define the full model. ","category":"page"},{"location":"NutsAndBolts/","page":"UDE model construction","title":"UDE model construction","text":"UniversalDiffEq.jl uses a state-space modeling framework to define and fit NODE and UDE models. State-space models are a class of time series models that describe time series data with a process model that describes the dynamics of a sequence of unobserved state variables u_t, as well as an observation model that defines the relationship between the state variables u_t and the observations x_t.  The process model f predicts value of the state variables one step ahead","category":"page"},{"location":"NutsAndBolts/","page":"UDE model construction","title":"UDE model construction","text":"hatu_t+Delta t  = f(u_t t Delta t theta_proc)","category":"page"},{"location":"NutsAndBolts/","page":"UDE model construction","title":"UDE model construction","text":"where Delta t is the time span between observations, and theta_proc is the process model parameters. The observation model maps from the state variables u_t to the observations","category":"page"},{"location":"NutsAndBolts/","page":"UDE model construction","title":"UDE model construction","text":"x_t = h(u_t t Delta t theta_obs)","category":"page"},{"location":"NutsAndBolts/","page":"UDE model construction","title":"UDE model construction","text":"where theta_obs is the observation model parameters. In addition to these primary functions, both the observation model and process model have a loss function to measure the accuracy of their predictions. This can be thought of as the likelihood models used in generalized linear models. For example, we can measure the performance of the process model with a normal likelihood","category":"page"},{"location":"NutsAndBolts/","page":"UDE model construction","title":"UDE model construction","text":"L(hatu_tu_t) = frac1sigma sqrt2pi e^-frac12(frachatu_t-u_tsigma)^2","category":"page"},{"location":"NutsAndBolts/","page":"UDE model construction","title":"UDE model construction","text":"where sigma is the variance of the prediction errors. Although in principle any likelihood can be used, we use the mean squared error in our base model specification. ","category":"page"},{"location":"NutsAndBolts/","page":"UDE model construction","title":"UDE model construction","text":"The UDE models also include submodels to regularize the process and observation models. The regularization models are functions of the model parameters that add to the loss function. The regularization models are in effect priors on the model parameters. Regularization is especially important for neural network models to reduce overfitting to training data and make the models more generalizable. For example, our default model constructors apply L2 regularization to neural network parameters in the process model","category":"page"},{"location":"NutsAndBolts/","page":"UDE model construction","title":"UDE model construction","text":"R(theta_proc) = omega theta_proc_L2","category":"page"},{"location":"NutsAndBolts/","page":"UDE model construction","title":"UDE model construction","text":"where omega is the weight given to regularization in the overall loss function. ","category":"page"},{"location":"NutsAndBolts/","page":"UDE model construction","title":"UDE model construction","text":"These six model components are all combined into one loss functions used to fit the UDE models","category":"page"},{"location":"NutsAndBolts/","page":"UDE model construction","title":"UDE model construction","text":"L(utheta_proctheta_obsx) = sum_t =1^T L_obs(x_th(u_ttheta_obs)sigma_obs) + sum_t=2^T L_proc(u_tf(u_t-1theta_proc)sigma_proc) + R_obs(theta_obs) + R_proc(theta_proc)","category":"page"},{"location":"NutsAndBolts/","page":"UDE model construction","title":"UDE model construction","text":"where the sigma_i are parameters for the loss functions and the theta_i are parameters for the prediction functions. ","category":"page"},{"location":"NutsAndBolts/","page":"UDE model construction","title":"UDE model construction","text":"The UDE object combines the observation and process models and their respective loss and regularization models into one larger model object along with the data used to fit the model.","category":"page"},{"location":"NutsAndBolts/","page":"UDE model construction","title":"UDE model construction","text":"UDE","category":"page"},{"location":"NutsAndBolts/#UniversalDiffEq.UDE-NutsAndBolts","page":"UDE model construction","title":"UniversalDiffEq.UDE","text":"UDE\n\nBasic data structure used to the model structure, parameters and data for UDE and NODE models.  ...\n\nElements\n\ntimes: a vector of times for each observation\ndata: a matrix of observaitons at each time point\nX: a DataFrame with any covariates used by the model\ndata_frame: a DataFrame with columns for the time of each observation and values of the state variables\nparameters: a ComponentArray that stores model parameters\nloss_function: the loss function used to fit the model\nprocess_model: a Julia mutable struct used to define model predictions \nprocess_loss: a Julia mutable struct used to measure the performance of model predictions\nobservation_model: a Julia mutable struct used to predict observaitons given state variable estimates\nobservaiton_loss: a Julia mutable struct used to measure the performance of the observation model\nprocess_regularization: a Julia mutable struct used to store data needed for process model regularization\nobservation_regularization: a Julia mutable struct used to store data needed for observation model regularization\nconstructor: A function that initializes a UDE model with identical structure.\n\n...\n\n\n\n\n\n","category":"type"},{"location":"NutsAndBolts/","page":"UDE model construction","title":"UDE model construction","text":"UniversalDiffEq.ProcessModel","category":"page"},{"location":"NutsAndBolts/#UniversalDiffEq.ProcessModel-NutsAndBolts","page":"UDE model construction","title":"UniversalDiffEq.ProcessModel","text":"ProcessModel\n\nA Julia mutable struct that stores the functions and parameters for the process model.  ...\n\nElements\n\nparameters: ComponentArray\npredict: Function the predict one time step ahead\nforecast: Function, a modified version of predict to improve performance when extrapolating\ncovariates: Function that returns the value of the covariates at each point in time. \n\n...\n\n\n\n\n\n","category":"type"},{"location":"NutsAndBolts/","page":"UDE model construction","title":"UDE model construction","text":"UniversalDiffEq.LossFunction","category":"page"},{"location":"NutsAndBolts/#UniversalDiffEq.LossFunction-NutsAndBolts","page":"UDE model construction","title":"UniversalDiffEq.LossFunction","text":"LossFunction\n\nA Julia mutable struct that stores the loss function and parameters. ...\n\nElements\n\nparameters: ComponentArray\nloss: Function \n\n...\n\n\n\n\n\n","category":"type"},{"location":"NutsAndBolts/","page":"UDE model construction","title":"UDE model construction","text":"UniversalDiffEq.Regularization  ","category":"page"},{"location":"NutsAndBolts/#UniversalDiffEq.Regularization-NutsAndBolts","page":"UDE model construction","title":"UniversalDiffEq.Regularization","text":"Regularization\n\nA Julia mutable struct that stores the loss function and parameters. ...\n\nElements\n\nreg_parameters: ComponentArray\nloss: Function \n\n...\n\n\n\n\n\n","category":"type"},{"location":"Models/#Model-Constructors","page":"Model Constructors","title":"Model Constructors","text":"","category":"section"},{"location":"Models/","page":"Model Constructors","title":"Model Constructors","text":"UniversalDiffEq.jl provides a set of functions to construct UDEs with varying levels of customization. The model constructors all require the data to be passed using a DataFrame object from the DataFrames.jl library. The data frame should be organized with a column for time named t, and the remaining columns should have the values of the state variables (y_i) at each point in time.","category":"page"},{"location":"Models/","page":"Model Constructors","title":"Model Constructors","text":"t y_1 y_2\n0.1 0.0 -1.1\n0.2 0.01 -0.9\n0.5 0.51 -1.05","category":"page"},{"location":"Models/","page":"Model Constructors","title":"Model Constructors","text":"Table: Example data set with two state variables","category":"page"},{"location":"Models/","page":"Model Constructors","title":"Model Constructors","text":"Currently, missing data are not supported, but irregular intervals between time points are allowed.","category":"page"},{"location":"Models/","page":"Model Constructors","title":"Model Constructors","text":"Each constructor function will require additional inputs to specify the model structure. For example, the CustomDerivatives function requires the user to supply the known functional forms through the derivs! argument. These arguments are described in detail in the subsection for each model type.","category":"page"},{"location":"Models/","page":"Model Constructors","title":"Model Constructors","text":"Finally, the constructor functions share a set of keyword arguments used to tune the model fitting procedure. These control the weights given to the process model, observation model, and regularization in the loss function. Larger values of the regualrization weight limit the compexity of the relationships learned by the neural network reducing the likeihood of overfitting. The observation weight controls how closely the estimates states u_t match the data y_t, smaller vlaus of the observation weight correspond to data sets with larger amount of observaiton error","category":"page"},{"location":"Models/","page":"Model Constructors","title":"Model Constructors","text":"proc_weight=1.0 : The weight given to the model predictions in loss function\nobs_weight=1.0 : The weight given to the state estimates in loss function\nreg_weight=0.0 : The weight given to regularization in the loss function.","category":"page"},{"location":"Models/","page":"Model Constructors","title":"Model Constructors","text":"In addition to these weighting parameters, the key word argument l control how far the model will extrapolates beyond the observed data before reverting to a default value extrap_rho when forecasting.   ","category":"page"},{"location":"Models/#Nonparametric-UDES-(Neural-Ordinary-differntial-equation)","page":"Model Constructors","title":"Nonparametric UDES (Neural Ordinary differntial equation)","text":"","category":"section"},{"location":"Models/","page":"Model Constructors","title":"Model Constructors","text":"UniversalDiffEq.jl has two funtions to build time series model that use a neural network to learn all of the relationship in the data. These models are sometimes refered to and nueral ordinary differnetial equations (NODEs). ","category":"page"},{"location":"Models/","page":"Model Constructors","title":"Model Constructors","text":"The functon NODE builds a continuous time UDE with a neurla network representing the right hand side of the differntial equation ","category":"page"},{"location":"Models/","page":"Model Constructors","title":"Model Constructors","text":"   fracdudt = NN(uwb)","category":"page"},{"location":"Models/","page":"Model Constructors","title":"Model Constructors","text":"The function NNDE construct a differnce equation with a nerual network on the right hand side","category":"page"},{"location":"Models/","page":"Model Constructors","title":"Model Constructors","text":"   x_t+1 = x_t + NN(x_t)","category":"page"},{"location":"Models/","page":"Model Constructors","title":"Model Constructors","text":"UniversalDiffEq.NODE(data;kwargs ... )\nUniversalDiffEq.NNDE(data;kwargs ...)","category":"page"},{"location":"Models/#UniversalDiffEq.NODE-Tuple{Any}-Models","page":"Model Constructors","title":"UniversalDiffEq.NODE","text":"NODE(data;kwargs ... )\n\nConstructs a nonparametric continuous time model for the data set data using a single layer neural network to represent the systems dynamics. \n\n# kwargs\n\ntime_column_name: Name of column in data that corresponds to time. Default is \"time\".    \nhidden_units: Number of neurons in hidden layer. Default is 10.\nseed: Fixed random seed for repeatable results. Default is 1.\nproc_weight: Weight of process error omega_{proc}. Default is 1.0.\nobs_weight: Weight of observation error omega_{obs}. Default is 1.0.\nreg_weight: Weight of regularization error omega_{reg}. Default is 10^-6.\nreg_type: Type of regularization, whether \"L1\" or \"L2\" regularization. Default is \"L2\".\nl: Extrapolation parameter for forecasting. Default is 0.25.\nextrap_rho: Extrapolation parameter for forecasting. Default is 0.0.\n\n\n\n\n\n","category":"method"},{"location":"Models/#UniversalDiffEq.NNDE-Tuple{Any}-Models","page":"Model Constructors","title":"UniversalDiffEq.NNDE","text":"NNDE(data;kwargs ...)\n\nConstructs a nonparametric discrete time model for the data set data using a single layer neural network to represent the systems dynamics. \n\n# kwargs\n\ntime_column_name: Name of column in data that corresponds to time. Default is \"time\".\nhidden_units: Number of neurons in hidden layer. Default is 10.\nseed: Fixed random seed for repeatable results. Default is 1.\nproc_weight: Weight of process error omega_{proc}. Default is 1.0.\nobs_weight: Weight of observation error omega_{obs}. Default is 1.0.\nreg_weight: Weight of regularization error omega_{reg}. Default is 10^-6.\nreg_type: Type of regularization, whether \"L1\" or \"L2\" regularization. Default is \"L2\".\nl: Extrapolation parameter for forecasting. Default is 0.25.\nextrap_rho: Extrapolation parameter for forecasting. Default is 0.0.\n\n\n\n\n\n","category":"method"},{"location":"Models/","page":"Model Constructors","title":"Model Constructors","text":"Covariates can be added to the model by supplying a second data frame X. This dataframe must have the same column name for time as the primary data set, but the time point do not need to match because the values of the covariates between time points included in the data frame X are interpolated using a linear spline. . The NODE and NNDE functions will append the value of the covariates at each point in time to the neural network inputs","category":"page"},{"location":"Models/","page":"Model Constructors","title":"Model Constructors","text":"   fracdxdt = NN(xX(t)wb) \n   x_t+1 = x_t + NN(x_t X(t))","category":"page"},{"location":"Models/","page":"Model Constructors","title":"Model Constructors","text":"UniversalDiffEq.NODE(data,X;kwargs ... )","category":"page"},{"location":"Models/#UniversalDiffEq.NODE-Tuple{Any, Any}-Models","page":"Model Constructors","title":"UniversalDiffEq.NODE","text":"NODE(data,X;kwargs ... )\n\nWhen a dataframe X is supplied the model will run with covariates. the argument X should have a column for time t with the value for time in the remaining columns. The values in X will be interpolated with a linear spline for values of time not included in the data frame. \n\ntime_column_name: Name of column in data that corresponds to time. Default is \"time\".  \nvariable_column_name: Name of column in data that corresponds to the variables. Default is \"variable\".\nvalue_column_name: Name of column in data that corresponds to the covariates. Default is \"value\".  \nhidden_units: Number of neurons in hidden layer. Default is 10.\nseed: Fixed random seed for repeatable results. Default is 1.\nproc_weight: Weight of process error omega_{proc}. Default is 1.0.\nobs_weight: Weight of observation error omega_{obs}. Default is 1.0.\nreg_weight: Weight of regularization error omega_{reg}. Default is 10^-6.\nreg_type: Type of regularization, whether \"L1\" or \"L2\" regularization. Default is \"L2\".\nl: Extrapolation parameter for forecasting. Default is 0.25.\nextrap_rho: Extrapolation parameter for forecasting. Default is 0.0.\n\n\n\n\n\n","category":"method"},{"location":"Models/","page":"Model Constructors","title":"Model Constructors","text":"Multiple covariates with differnt observaiton frequencies can be supplied to the model with a long formate data set. If a long formate data set is provided the user must spcify which column containt the variable names and which column contains the value of the variable using the variable_column_name and value_column_name key word arguments. In the example below the variable column name is \"variable\" and the value column name is \"value","category":"page"},{"location":"Models/","page":"Model Constructors","title":"Model Constructors","text":"t variable value\n1.0 X_1 -1.1\n2.0 X_1 -0.9\n3.0 X_1 -1.05\n... ... ...\n1.0 X_2 3.0\n2.0 X_2 0.95\n4.0 X_2 -1.25","category":"page"},{"location":"Models/","page":"Model Constructors","title":"Model Constructors","text":"Table: Example covariate data in long format","category":"page"},{"location":"Models/#Customizing-universal-dynamic-equaitons","page":"Model Constructors","title":"Customizing universal dynamic equaitons","text":"","category":"section"},{"location":"Models/#Continuous-time-models","page":"Model Constructors","title":"Continuous time models","text":"","category":"section"},{"location":"Models/","page":"Model Constructors","title":"Model Constructors","text":"The CustomDerivatives and CustomDifference functions can be used to build models that combine neural networks and known functional forms. These functions take user-defined models, construct a loss function, and provide access to the model fitting and testing functions provided by UniversalDiffEq.jl.","category":"page"},{"location":"Models/","page":"Model Constructors","title":"Model Constructors","text":"The CustomDerivatives function builds SS-UDE models based on a user-defined function derivs!(du,u,p,t), which updates the vector du with the right-hand side of a differential equation evaluated at time t in state u given parameters p. The function also needs an initial guess at the model parameters, specified by a NamedTuple initial_parameters","category":"page"},{"location":"Models/","page":"Model Constructors","title":"Model Constructors","text":"UniversalDiffEq.CustomDerivatives(data,derivs!,initial_parameters;kwargs ... )","category":"page"},{"location":"Models/#UniversalDiffEq.CustomDerivatives-Tuple{Any, Any, Any}-Models","page":"Model Constructors","title":"UniversalDiffEq.CustomDerivatives","text":"CustomDerivatives(data,derivs!,initial_parameters;kwargs ... )\n\nConstructs a UDE model for the data set data  based on user defined derivatives derivs. An initial guess of model parameters are supplied with the initial_parameters argument. \n\n...\n\nArguments\n\ndata: a DataFrame object with the time of observations in a column labeled t and the remaining columns the value of the state variables at each time point. \nderivs: a Function of the form derivs!(du,u,p,t) where u is the value of the state variables, p are the model parameters, t is time, and du is updated with the value of the derivatives\ninit_parameters: A NamedTuple with the model parameters. Neural network parameters must be listed under the key NN.\n\nkwargs\n\ntime_column_name: Name of column in data that corresponds to time. Default is \"time\".\nproc_weight: Weight of process error omega_{proc}. Default is 1.0.\nobs_weight: Weight of observation error omega_{obs}. Default is 1.0.\nreg_weight: Weight of regularization error omega_{reg}. Default is 10^-6.\nreg_type: Type of regularization, whether \"L1\" or \"L2\" regularization. Default is \"L2\".\nl: Extrapolation parameter for forecasting. Default is 0.25.\nextrap_rho: Extrapolation parameter for forecasting. Default is 0.0.\n\n...\n\n\n\n\n\n","category":"method"},{"location":"Models/#Example","page":"Model Constructors","title":"Example","text":"","category":"section"},{"location":"Models/","page":"Model Constructors","title":"Model Constructors","text":"The following block of code shows how to build a UDE model based on the Lotka-Volterra predator-prey model where the growth rate of the prey r, mortality rate of the predator m, and conversion efficiency theta are estimated and the predation rate is described by a neural network NN. The equatns for the ODE are","category":"page"},{"location":"Models/","page":"Model Constructors","title":"Model Constructors","text":"fracdNdt = rN - NN(NP) \nfracdPdt = theta NN(NP) - mP","category":"page"},{"location":"Models/","page":"Model Constructors","title":"Model Constructors","text":"To implement the model we start by defining the neural network and initializing its parameters using the Lux.Chain and  Lux.setup functions. ","category":"page"},{"location":"Models/","page":"Model Constructors","title":"Model Constructors","text":"using Lux\n# Build the neural network with Lux.Chain \ndims_in = 2\nhidden_units = 10\nnonlinearity = tanh\ndims_out = 1\nNN = Lux.Chain(Lux.Dense(dims_in,hidden_units,nonlinearity),Lux.Dense(hidden_units,dims_out))\n\n# initialize the neural network states and parameters \nusing Random\nrng = Random.default_rng() \nNNparameters, states = Lux.setup(rng,NN) ","category":"page"},{"location":"Models/","page":"Model Constructors","title":"Model Constructors","text":"With hte neurla network in hand we can define the derivatives of the differntial equaitons model using standard Julia syntax. The derivs function first evaluates the neural network given the abundance of the predators and prey in the vector u. The neural network function NN requires three arguments: the current state, the network parameters, and the network states. In this example, the weights and biases are accessed through the parameters NamedTuple p with the key NN. The other model parameters are accessed with keys corresponding to their respective names.","category":"page"},{"location":"Models/","page":"Model Constructors","title":"Model Constructors","text":"function lotka_volterra_derivs!(du,u,p,t)\n    C, states = NN(u,p.NN,states) \n    du[1] = p.r*u[1] - C[1]\n    du[2] = p.theta*C[1] -p.m*u[2]\nend","category":"page"},{"location":"Models/","page":"Model Constructors","title":"Model Constructors","text":"Finally, we can define the initial parameters as a NamedTuple and build the model using the CustomDerivatives function.","category":"page"},{"location":"Models/","page":"Model Constructors","title":"Model Constructors","text":"using UniversalDiffEq\ninitial_parameters = (NN = NNparameters, r = 1.0, m = 0.5, theta = 0.5)\nmodel = CustomDerivatives(data,lotka_volterra_derivs!,initial_parameters)","category":"page"},{"location":"Models/#Discrete-time-model","page":"Model Constructors","title":"Discrete time model","text":"","category":"section"},{"location":"Models/","page":"Model Constructors","title":"Model Constructors","text":"Discrete time models are constructed in a similar way to continuous time models. The user provides the right-hand side of a difference equation with the function step and initial parameters. The function step(u,t,p) takes three arguments: the value of the state variables u, time t, and model parameters p. ","category":"page"},{"location":"Models/","page":"Model Constructors","title":"Model Constructors","text":"UniversalDiffEq.CustomDifference(data,step,initial_parameters;kwrags...)","category":"page"},{"location":"Models/#UniversalDiffEq.CustomDifference-Tuple{Any, Any, Any}-Models","page":"Model Constructors","title":"UniversalDiffEq.CustomDifference","text":"CustomDifference(data,step,initial_parameters;kwrags...)\n\nConstructs a UDE model for the data set data based on user defined difference equation step. An initial guess of model parameters are supplied with the initial_parameters argument. ...\n\nArguments\n\ndata: a DataFrame object with the time of observations in a column labeled t and the remaining columns the value of the state variables at each time point. \nstep: a Function of the form step(u,t,p) where u is the value of the state variables, p are the model parameters.\ninit_parameters: A NamedTuple with the model parameters. Neural network parameters must be listed under the key NN.\n\nkwargs\n\ntime_column_name: Name of column in data that corresponds to time. Default is \"time\".\nproc_weight: Weight of process error omega_{proc}. Default is 1.0.\nobs_weight: Weight of observation error omega_{obs}. Default is 1.0.\nreg_weight: Weight of regularization error omega_{reg}. Default is 10^-6.\nreg_type: Type of regularization, whether \"L1\" or \"L2\" regularization. Default is \"L2\".\nl: Extrapolation parameter for forecasting. Default is 0.25.\nextrap_rho: Extrapolation parameter for forecasting. Default is 0.0.\n\n...\n\n\n\n\n\n","category":"method"},{"location":"Models/#Adding-covariates","page":"Model Constructors","title":"Adding covariates","text":"","category":"section"},{"location":"Models/","page":"Model Constructors","title":"Model Constructors","text":"Covariates can also be added to UDE models by passing a data frame X and adding covariates as an argument to the derivs! function which has the new form derivs!(du,u,X,p,t), where the third argument X is a vector of covariates. ","category":"page"},{"location":"Models/","page":"Model Constructors","title":"Model Constructors","text":"UniversalDiffEq.CustomDerivatives(data::DataFrame,X,derivs!::Function,initial_parameters;kwargs ... )","category":"page"},{"location":"Models/#UniversalDiffEq.CustomDerivatives-Tuple{DataFrame, Any, Function, Any}-Models","page":"Model Constructors","title":"UniversalDiffEq.CustomDerivatives","text":"CustomDerivatives(data::DataFrame,X,derivs!::Function,initial_parameters;kwargs ... )\n\nWhen a dataframe X is supplied the model will run with covariates. the argument X should have a column for time t with the value for time in the remaining columns. The values in X will be interpolated with a linear spline for value of time not included in the data frame. \n\nWhen X is provided the derivs function must have the form derivs!(du,u,x,p,t) where x is a vector with the value of the covariates at time t. \n\nkwargs\n\ntime_column_name: Name of column in data that corresponds to time. Default is \"time\".\nvariable_column_name: Name of column in data that corresponds to the variables. Default is \"variable\".\nvalue_column_name: Name of column in data that corresponds to the covariates. Default is \"value\".\nproc_weight: Weight of process error omega_{proc}. Default is 1.0.\nobs_weight: Weight of observation error omega_{obs}. Default is 1.0.\nreg_weight: Weight of regularization error omega_{reg}. Default is 10^-6.\nreg_type: Type of regularization, whether \"L1\" or \"L2\" regularization. Default is \"L2\".\nl: Extrapolation parameter for forecasting. Default is 0.25.\nextrap_rho: Extrapolation parameter for forecasting. Default is 0.0.\n\n\n\n\n\n","category":"method"},{"location":"Models/","page":"Model Constructors","title":"Model Constructors","text":"Covariates can also be added to a discrete time framework in the same way. The step function should have four arguments step(u,X,t,p).","category":"page"},{"location":"Models/","page":"Model Constructors","title":"Model Constructors","text":"UniversalDiffEq.CustomDifference(data::DataFrame,X,step,initial_parameters;kwargs ... )","category":"page"},{"location":"Models/#UniversalDiffEq.CustomDifference-Tuple{DataFrame, Any, Any, Any}-Models","page":"Model Constructors","title":"UniversalDiffEq.CustomDifference","text":"CustomDifference(data::DataFrame,X,step,initial_parameters;kwargs ... )\n\nWhen a dataframe X is supplied the model will run with covariates. the argument X should have a column for time t with the value for time in the remaining columns. The values in X will be interpolated with a linear spline for value of time not included in the data frame. \n\nWhen X is provided the step function must have the form step(u,x,t,p) where x is a vector with the value of the covariates at time t. \n\n# kwargs\n\ntime_column_name: Name of column in data that corresponds to time. Default is \"time\".\nvariable_column_name: Name of column in data that corresponds to the variables. Default is \"variable\".\nvalue_column_name: Name of column in data that corresponds to the covariates. Default is \"value\".\nproc_weight: Weight of process error omega_{proc}. Default is 1.0.\nobs_weight: Weight of observation error omega_{obs}. Default is 1.0.\nreg_weight: Weight of regularization error omega_{reg}. Default is 10^-6.\nreg_type: Type of regularization, whether \"L1\" or \"L2\" regularization. Default is \"L2\".\nl: Extrapolation parameter for forecasting. Default is 0.25.\nextrap_rho: Extrapolation parameter for forecasting. Default is 0.0.\n\n\n\n\n\n","category":"method"},{"location":"Models/#Example-2","page":"Model Constructors","title":"Example","text":"","category":"section"},{"location":"Models/","page":"Model Constructors","title":"Model Constructors","text":"To show how adding covariates can work, the following example extends the Lotka-Volterra equations defined above to incorporate a covariate X that influences the abundance of predators and prey. We can model this as a linear effect with coefficients beta_N and beta_P","category":"page"},{"location":"Models/","page":"Model Constructors","title":"Model Constructors","text":"fracdNdt = rN - NN(NP) + beta_N N \nfracdPdt = theta NN(NP) - mP + beta_P P","category":"page"},{"location":"Models/","page":"Model Constructors","title":"Model Constructors","text":"# set up neural network \nusing Lux\ndims_in = 2\nhidden_units = 10\nnonlinearity = tanh\ndims_out = 1\nNN = Lux.Chain(Lux.Dense(dims_in,hidden_units,nonlinearity),Lux.Dense(hidden_units,dims_out))\n\n# initialize parameters \nusing Random\nrng = Random.default_rng() \nNNparameters, NNstates = Lux.setup(rng,NN) \n\nfunction derivs!(du,u,X,p,t)\n    C, states = NN(u,p.NN, NNstates) # NNstates are\n    du[1] = p.r*u[1] - C[1] + p.beta[1] * X[1]\n    du[2] = p.theta*C[1] -p.m*u[2] + p.beta[2] * X[1]\nend\n\ninit_parameters = (NN = NNparameters, r = 1.0, m = 0.5, theta = 0.5, beta = [0,0])\n\n\nmodel = CustomDerivatives(training_data,X,derivs!;init_parameters;proc_weight=2.0,obs_weight=0.5,reg_weight=10^-4)\nnothing","category":"page"},{"location":"Models/#Covariates-with-different-sampling-frequencies","page":"Model Constructors","title":"Covariates with different sampling frequencies","text":"","category":"section"},{"location":"Models/","page":"Model Constructors","title":"Model Constructors","text":"If you wish to build a model with covariates that are measured at different points in time, then you can provide a list of data frames as the covariates argument. Each data frame in the list should have time in the first column and the value of one of the covariates in the second column. The model will interpolate each time series with a linear spline. The value of the covariates can be accessed in the derivs and step functions for custom models by indexing into the covariates argument X. The values will be listed in the same order as the data frames are provided in the covariates argument.","category":"page"},{"location":"Models/#Adding-prior-information-to-custom-models","page":"Model Constructors","title":"Adding prior information to custom models","text":"","category":"section"},{"location":"Models/","page":"Model Constructors","title":"Model Constructors","text":"UniversalDiffEq.CustomDerivatives(data::DataFrame,derivs!::Function,initial_parameters,priors::Function;kwargs ... )\nUniversalDiffEq.CustomDifference(data::DataFrame,step,initial_parameters,priors::Function;kwargs ... )","category":"page"},{"location":"Models/#UniversalDiffEq.CustomDerivatives-Tuple{DataFrame, Function, Any, Function}-Models","page":"Model Constructors","title":"UniversalDiffEq.CustomDerivatives","text":"CustomDerivatives(data::DataFrame,derivs!::Function,initial_parameters,priors::Function;kwargs ... )\n\nWhen a function's priors is supplied its value will be added to the loss function as a penalty term for user specified parameters. It should take the a single NamedTuple p as an argument penalties for each paramter should be calculated by accessing p with the period operator.\n\nThe prior function can be used to nudge the fitted model toward prior expectations for a parameter value. For example, the following function increases the loss when a parameter p.r has a value other than 1.5, nad a second parameter p.beta is greater than zeros. \n\nfunction priors(p)\n    l = 0.01*(p.r - 1.5)^2\n    l += 0.01*(p.beta)^2\n    return l\nend \n\nkwargs\n\ntime_column_name: Name of column in data that corresponds to time. Default is \"time\".\nproc_weight: Weight of process error omega_{proc}. Default is 1.0.\nobs_weight: Weight of observation error omega_{obs}. Default is 1.0.\nreg_weight: Weight of regularization error omega_{reg}. Default is 10^-6.\nreg_type: Type of regularization, whether \"L1\" or \"L2\" regularization. Default is \"L2\".\nl: Extrapolation parameter for forecasting. Default is 0.25.\nextrap_rho: Extrapolation parameter for forecasting. Default is 0.0.\n\n\n\n\n\n","category":"method"},{"location":"Models/#UniversalDiffEq.CustomDifference-Tuple{DataFrame, Any, Any, Function}-Models","page":"Model Constructors","title":"UniversalDiffEq.CustomDifference","text":"CustomDifference(data::DataFrame,step,initial_parameters,priors::Function;kwargs ... )\n\nWhen a function's priors is supplied its value will be added to the loss function as a penalty term for user specified paramters. It should take the a single NamedTuple p as an argument penalties for each parameter should be calcualted by accessing p with the period operator. \n\nfunction priors(p)\n    l = 0.01*(p.r - 1.5)^2\n    l += 0.01*(p.beta)^2\n    return l\nend \n\nkwargs\n\ntime_column_name: Name of column in data that corresponds to time. Default is \"time\".\nproc_weight: Weight of process error omega_{proc}. Default is 1.0.\nobs_weight: Weight of observation error omega_{obs}. Default is 1.0.\nreg_weight: Weight of regularization error omega_{reg}. Default is 10^-6.\nreg_type: Type of regularization, whether \"L1\" or \"L2\" regularization. Default is \"L2\".\nl: Extrapolation parameter for forecasting. Default is 0.25.\nextrap_rho: Extrapolation parameter for forecasting. Default is 0.0.\n\n\n\n\n\n","category":"method"},{"location":"ModelTesting/#Test-models","page":"Test models","title":"Test models","text":"","category":"section"},{"location":"ModelTesting/","page":"Test models","title":"Test models","text":"UniversalDiffEq.jl provides a number of functions to test the performance of NODE and UDE models, with both in-sample and out-of-sample data. ","category":"page"},{"location":"ModelTesting/#Evaluating-model-fits","page":"Test models","title":"Evaluating model fits","text":"","category":"section"},{"location":"ModelTesting/","page":"Test models","title":"Test models","text":"There are two primary functions to test model fits: plot_state_estimates and plot_predictions. The model fitting procedure estimates the value of the state variables hatu at each time point in the data set as well as the parameters of the NODE or UDE model that predicts changes in the state variables. The plot_state_estimates function compares the estimated states to the data to check the quality of the state estimates, and plot_predictions compares the predictions of UDE model one step into the future to the estimated sequence of state variables. Both functions take a UDE as an input and return a plot showing the correspondence between model predictions and observations. ","category":"page"},{"location":"ModelTesting/","page":"Test models","title":"Test models","text":"UniversalDiffEq.plot_state_estimates(UDE::UDE)\nUniversalDiffEq.plot_predictions(UDE::UDE)","category":"page"},{"location":"ModelTesting/#UniversalDiffEq.plot_state_estimates-Tuple{UDE}-ModelTesting","page":"Test models","title":"UniversalDiffEq.plot_state_estimates","text":"plot_state_estimates(UDE::UDE)\n\nPlots the values of the state variables estimated by the UDE model.\n\n\n\n\n\n","category":"method"},{"location":"ModelTesting/#UniversalDiffEq.plot_predictions-Tuple{UDE}-ModelTesting","page":"Test models","title":"UniversalDiffEq.plot_predictions","text":"plot_predictions(UDE::UDE)\n\nPlots the correspondence between the observed state transitions and the predictions from the UDE model.\n\n\n\n\n\n","category":"method"},{"location":"ModelTesting/","page":"Test models","title":"Test models","text":"There are also functions to compare the model predictions to out-of-sample data. The simplest is plot_forecast, which compares the observations in the test data set to a deterministic simulation from the data set, which starts at the first observation and runs to the end of the test data. ","category":"page"},{"location":"ModelTesting/","page":"Test models","title":"Test models","text":"UniversalDiffEq.plot_forecast(UDE::UDE, test_data::DataFrame)","category":"page"},{"location":"ModelTesting/#UniversalDiffEq.plot_forecast-Tuple{UDE, DataFrame}-ModelTesting","page":"Test models","title":"UniversalDiffEq.plot_forecast","text":"plot_forecast(UDE::UDE, test_data::DataFrame)\n\nPlots the model's forecast over the range of the test data along with the value of the test data.\n\n\n\n\n\n","category":"method"},{"location":"ModelTesting/","page":"Test models","title":"Test models","text":"It is also possible to test the performance of the models one time step into the future using the plot_predictions function. When a test data set is supplied to the plot_predictions function, it will run a series of forecasts starting at each point in the data set, predicting one time step into the future. The function returns a plot comparing the predicted and observed changes.","category":"page"},{"location":"ModelTesting/","page":"Test models","title":"Test models","text":"UniversalDiffEq.plot_predictions(UDE::UDE, test_data::DataFrame)","category":"page"},{"location":"ModelTesting/#UniversalDiffEq.plot_predictions-Tuple{UDE, DataFrame}-ModelTesting","page":"Test models","title":"UniversalDiffEq.plot_predictions","text":"plot_predictions(UDE::UDE, test_data::DataFrame)\n\nPlots the correspondence between the observed state transitions in test data and the predictions from the UDE model.\n\n\n\n\n\n","category":"method"},{"location":"ModelTesting/#Cross-validation","page":"Test models","title":"Cross-validation","text":"","category":"section"},{"location":"ModelTesting/","page":"Test models","title":"Test models","text":"Cross-validation is important for model comparison and hyper-parameter tuning. The leave_future_out_cv function breaks the data set into training and test data sets by leaving off the final observations in the data set. The model is then trained on the beginning of the data set and the performance is calculated by comparing a forecast to the test data. The user can specify the time horizon for the forecast T_Forecast and the number of tests K. The first test trains the model on the full data set only omitting the final T_forecast years as the test set. The remaining tests each generate a new test data set by iteratively removing more of the observations from the end of the data set. The number removed between each test can be controlled by changing the spacing argument. The kfold_cv function performs a k-fold version of leave_future_out_cv.","category":"page"},{"location":"ModelTesting/","page":"Test models","title":"Test models","text":"UniversalDiffEq.leave_future_out_cv(model::UDE)\nUniversalDiffEq.kfold_cv(model::UDE)","category":"page"},{"location":"ModelTesting/#UniversalDiffEq.leave_future_out_cv-Tuple{UDE}-ModelTesting","page":"Test models","title":"UniversalDiffEq.leave_future_out_cv","text":"leave_future_out_cv(model::UDE; kwargs ...)\n\nRuns K fold leave future out cross validation and returns the mean squared forecasting error and a plot to visualize the model fits.\n\n...\n\nArguments\n\nmodel - the UDE model to test forecastlength = 5 - The number of data points to forecast forecastnumber = 10 - The number of trainin gnad testing data sets to create spacing = 2 - The number of data points to skip between the end of each new triaining data set BFGS=false - use BFGS algorithm to train the model stepsize = 0.05 - step size for first run of the ADAM algorithm  maxiter = 500 - maximum iterations for first trial of ADAM stepsize2 = 0.01 - step size for second iteration of ADAM, only used of BFGS is false maxiter2 = 500 - step size for second iteration of ADAM, only used of BFGS is false ...\n\n\n\n\n\n","category":"method"},{"location":"ModelTesting/#UniversalDiffEq.kfold_cv-Tuple{UDE}-ModelTesting","page":"Test models","title":"UniversalDiffEq.kfold_cv","text":"kfold_cv(model::UDE; kwargs ...)\n\nRuns K fold leave future out cross validation and returns the mean squared forecasting error and a plot to visualize the model fits.\n\n...\n\nArguments\n\nmodel - a UDE model object k=10 - the number of testing and taining data sets to build leaveout=5 - the number of data points to leave out in each testingdata set BFGS = false - use the BFGS algorithm to train the model stepsize = 0.05 - step size for first run of the ADAM algorithm  maxiter = 500 - maximum iterations for first trial of ADAM step_size2 = 0.01 - step size for second iteration of ADAM, only used of BFGS is false maxiter2 = 500 - step size for second iteration of ADAM, only used of BFGS is false ...\n\n\n\n\n\n","category":"method"},{"location":"ODEAnalysis/#Analyzing-fitted-models","page":"Analyzing fitted models","title":"Analyzing fitted models","text":"","category":"section"},{"location":"ODEAnalysis/","page":"Analyzing fitted models","title":"Analyzing fitted models","text":"UniversalDiffEq.equilibrium_and_stability(UDE,lower,upper;t=0,Ntrials=100,tol=10^-3)\nUniversalDiffEq.equilibrium_and_stability(UDE,X,lower,upper;t=0,Ntrials=100,tol=10^-3)\nUniversalDiffEq.equilibrium_and_stability(UDE::MultiUDE,site,X,lower,upper;t=0,Ntrials=100,tol=10^-3)","category":"page"},{"location":"ODEAnalysis/#UniversalDiffEq.equilibrium_and_stability-Tuple{Any, Any, Any}-ODEAnalysis","page":"Analyzing fitted models","title":"UniversalDiffEq.equilibrium_and_stability","text":"equilibrium_and_stability(UDE,lower,upper;t=0,Ntrials=100,tol=10^-3)\n\nAttempts to find all the equilibirum points for the UDE model between the upper and lower bound and return the real component of the leading eigen value to analyze stability. \n\n...\n\nkwargs\n\nt = 0: The point in time where the UDE model is evaluated, only relevant for time aware UDEs.\nNtrials = 100: the number of initializations of the root finding algorithm. \ntol = 10^-3: The threshold euclidean distance between point beyond which a new equilbirum is sufficently different to be retained. \n\n...\n\n\n\n\n\n","category":"method"},{"location":"ODEAnalysis/#UniversalDiffEq.equilibrium_and_stability-NTuple{4, Any}-ODEAnalysis","page":"Analyzing fitted models","title":"UniversalDiffEq.equilibrium_and_stability","text":"equilibrium_and_stability(UDE,X,lower,upper;t=0,Ntrials=100,tol=10^-3)\n\nAttempts to find all the equilibirum points for the UDE model between the upper and lower bound and return the real component of the leading eigen value to analyze stability. \n\n...\n\nkwargs\n\nt = 0: The point in time where the UDE model is evaluated, only relevant for time aware UDEs.\nNtrials = 100: the number of initializations of the root finding algorithm. \ntol = 10^-3: The threshold euclidean distance between point beyond which a new equilbirum is sufficently different to be retained. \n\n...\n\n\n\n\n\n","category":"method"},{"location":"ODEAnalysis/#UniversalDiffEq.equilibrium_and_stability-Tuple{MultiUDE, Any, Any, Any, Any}-ODEAnalysis","page":"Analyzing fitted models","title":"UniversalDiffEq.equilibrium_and_stability","text":"equilibrium_and_stability(UDE::MultiUDE,site,X,lower,upper;t=0,Ntrials=100,tol=10^-3)\n\nAttempts to find all the equilibirum points for the UDE model between the upper and lower bound and return the real component of the leading eigen value to analyze stability. \n\n...\n\nkwargs\n\nt = 0: The point in time where the UDE model is evaluated, only relevant for time aware UDEs.\nNtrials = 100: the number of initializations of the root finding algorithm. \ntol = 10^-3: The threshold euclidean distance between point beyond which a new equilbirum is sufficently different to be retained. \n\n...\n\n\n\n\n\n","category":"method"},{"location":"API/#API","page":"API","title":"API","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"Modules = [UniversalDiffEq]","category":"page"},{"location":"API/#UniversalDiffEq.BayesianUDE","page":"API","title":"UniversalDiffEq.BayesianUDE","text":"BayesianUDE\n\nBasic data structure used to the model structure, parameters and data for Bayesian UDE and NODE models.  ...\n\nElements\n\ntimes: a vector of times for each observation\ndata: a matrix of observaitons at each time point\nX: a DataFrame with any covariates used by the model\ndata_frame: a DataFrame with columns for the time of each observation and values of the state variables\nparameters: a ComponentArray that stores model parameters\nloss_function: the loss function used to fit the model\nprocess_model: a Julia mutable struct used to define model predictions \nprocess_loss: a Julia mutable struct used to measure the performance of model predictions\nobservation_model: a Julia mutable struct used to predict observaitons given state variable estimates\nobservaiton_loss: a Julia mutable struct used to measure the performance of the observation model\nprocess_regularization: a Julia mutable struct used to store data needed for process model regularization\nobservation_regularization: a Julia mutable struct used to store data needed for observation model regularization\nconstructor: A function that initializes a UDE model with identical structure. \n\n...\n\n\n\n\n\n","category":"type"},{"location":"API/#UniversalDiffEq.LossFunction","page":"API","title":"UniversalDiffEq.LossFunction","text":"LossFunction\n\nA Julia mutable struct that stores the loss function and parameters. ...\n\nElements\n\nparameters: ComponentArray\nloss: Function \n\n...\n\n\n\n\n\n","category":"type"},{"location":"API/#UniversalDiffEq.MultiProcessModel","page":"API","title":"UniversalDiffEq.MultiProcessModel","text":"MultiProcessModel\n\nA Julia mutable struct that stores the functions and parameters for the process model.  ...\n\nElements\n\nparameters: ComponentArray\npredict: Function that predicts one time step ahead\nforecast: Function that is a modified version of predict to improve performace when extrapolating\ncovariates: Function that returns the values of the covariates at each point in time\nright_hand_side: Function that returns the right-hand side of a differential equation (i.e., the relationships between state variables and parameters)\n\n...\n\n\n\n\n\n","category":"type"},{"location":"API/#UniversalDiffEq.ProcessModel","page":"API","title":"UniversalDiffEq.ProcessModel","text":"ProcessModel\n\nA Julia mutable struct that stores the functions and parameters for the process model.  ...\n\nElements\n\nparameters: ComponentArray\npredict: Function the predict one time step ahead\nforecast: Function, a modified version of predict to improve performance when extrapolating\ncovariates: Function that returns the value of the covariates at each point in time. \n\n...\n\n\n\n\n\n","category":"type"},{"location":"API/#UniversalDiffEq.Regularization","page":"API","title":"UniversalDiffEq.Regularization","text":"Regularization\n\nA Julia mutable struct that stores the loss function and parameters. ...\n\nElements\n\nreg_parameters: ComponentArray\nloss: Function \n\n...\n\n\n\n\n\n","category":"type"},{"location":"API/#UniversalDiffEq.UDE","page":"API","title":"UniversalDiffEq.UDE","text":"UDE\n\nBasic data structure used to the model structure, parameters and data for UDE and NODE models.  ...\n\nElements\n\ntimes: a vector of times for each observation\ndata: a matrix of observaitons at each time point\nX: a DataFrame with any covariates used by the model\ndata_frame: a DataFrame with columns for the time of each observation and values of the state variables\nparameters: a ComponentArray that stores model parameters\nloss_function: the loss function used to fit the model\nprocess_model: a Julia mutable struct used to define model predictions \nprocess_loss: a Julia mutable struct used to measure the performance of model predictions\nobservation_model: a Julia mutable struct used to predict observaitons given state variable estimates\nobservaiton_loss: a Julia mutable struct used to measure the performance of the observation model\nprocess_regularization: a Julia mutable struct used to store data needed for process model regularization\nobservation_regularization: a Julia mutable struct used to store data needed for observation model regularization\nconstructor: A function that initializes a UDE model with identical structure.\n\n...\n\n\n\n\n\n","category":"type"},{"location":"API/#UniversalDiffEq.BFGS!-Tuple{Any}","page":"API","title":"UniversalDiffEq.BFGS!","text":" BFGS!(UDE, kwargs ...)\n\nminimizes the loss function of the UDE model using the BFGS algorithm is the inital step norm equal to initial_step_norm. The funciton will print the value fo the loss function after each iteration when verbose is true.  \n\nkwargs\n\ninitial_step_norm: Initial step norm for BFGS algorithm. Default is 0.01.\nverbose: Should the training loss values be printed?. Default is false.\n\n\n\n\n\n\n\n","category":"method"},{"location":"API/#UniversalDiffEq.BayesianCustomDerivatives-Tuple{DataFrame, Any, Function, Any}","page":"API","title":"UniversalDiffEq.BayesianCustomDerivatives","text":"BayesianCustomDerivatives(data::DataFrame,X,derivs!::Function,initial_parameters;kwargs ... )\n\nWhen a dataframe X is supplied the model will run with covariates. the argument X should have a column for time t with the value for time in the remaining columns. The values in X will be interpolated with a linear spline for value of time not included in the data frame. \n\nWhen X is provided the derivs function must have the form derivs!(du,u,x,p,t) where x is a vector with the value of the covariates at time t. \n\nkwargs\n\ntime_column_name: Name of column in data that corresponds to time. Default is \"time\".  \nvariable_column_name: Name of column in data that corresponds to the variables. Default is \"variable\".\nvalue_column_name: Name of column in data that corresponds to the covariates. Default is \"value\".  \nhidden_units: Number of neurons in hidden layer. Default is 10.\nseed: Fixed random seed for repeatable results. Default is 1.\nproc_weight: Weight of process error omega_{proc}. Default is 1.0.\nobs_weight: Weight of observation error omega_{obs}. Default is 1.0.\nreg_weight: Weight of regularization error omega_{reg}. Default is 10^-6.\nreg_type: Type of regularization, whether \"L1\" or \"L2\" regularization. Default is \"L2\".\nl: Extrapolation parameter for forecasting. Default is 0.25.\nextrap_rho: Extrapolation parameter for forecasting. Default is 0.0.\n\n\n\n\n\n","category":"method"},{"location":"API/#UniversalDiffEq.BayesianCustomDerivatives-Tuple{DataFrame, Function, Any}","page":"API","title":"UniversalDiffEq.BayesianCustomDerivatives","text":"BayesianCustomDerivatives(data::DataFrame,derivs!::Function,initial_parameters;kwargs ... )\n\nConstructs a Bayesian UDE model for the data set data  based on user defined derivatives derivs. An initial guess of model parameters are supplied with the initial_parameters argument. \n\n...\n\nArguments\n\ndata: a DataFrame object with the time of observations in a column labeled t and the remaining columns the value of the state variables at each time point. \nderivs: a Function of the form derivs!(du,u,p,t) where u is the value of the state variables, p are the model parameters, t is time, and du is updated with the value of the derivatives\ninit_parameters: A NamedTuple with the model parameters. Neural network parameters must be listed under the key NN.\n\nkwargs\n\ntime_column_name: Name of column in data that corresponds to time. Default is \"time\".  \nhidden_units: Number of neurons in hidden layer. Default is 10.\nseed: Fixed random seed for repeatable results. Default is 1.\nproc_weight: Weight of process error omega_{proc}. Default is 1.0.\nobs_weight: Weight of observation error omega_{obs}. Default is 1.0.\nreg_weight: Weight of regularization error omega_{reg}. Default is 10^-6.\nreg_type: Type of regularization, whether \"L1\" or \"L2\" regularization. Default is \"L2\".\nl: Extrapolation parameter for forecasting. Default is 0.25.\nextrap_rho: Extrapolation parameter for forecasting. Default is 0.0.\n\n...\n\n\n\n\n\n","category":"method"},{"location":"API/#UniversalDiffEq.BayesianNODE-Tuple{Any, Any}","page":"API","title":"UniversalDiffEq.BayesianNODE","text":"BayesianNODE(data,X;kwargs ... )\n\nWhen a dataframe X is supplied the model will run with covariates. the argument X should have a column for time t with the value for time in the remaining columns. The values in X will be interpolated with a linear spline for values of time not included in the data frame. \n\nkwargs\n\ntime_column_name: Name of column in data that corresponds to time. Default is \"time\".  \nvariable_column_name: Name of column in data that corresponds to the variables. Default is \"variable\".\nvalue_column_name: Name of column in data that corresponds to the covariates. Default is \"value\".  \nhidden_units: Number of neurons in hidden layer. Default is 10.\nseed: Fixed random seed for repeatable results. Default is 1.\nproc_weight: Weight of process error omega_{proc}. Default is 1.0.\nobs_weight: Weight of observation error omega_{obs}. Default is 1.0.\nreg_weight: Weight of regularization error omega_{reg}. Default is 10^-6.\nreg_type: Type of regularization, whether \"L1\" or \"L2\" regularization. Default is \"L2\".\nl: Extrapolation parameter for forecasting. Default is 0.25.\nextrap_rho: Extrapolation parameter for forecasting. Default is 0.0.\n\n\n\n\n\n","category":"method"},{"location":"API/#UniversalDiffEq.BayesianNODE-Tuple{Any}","page":"API","title":"UniversalDiffEq.BayesianNODE","text":"BayesianNODE(data;kwargs ... )\n\nConstructs a Bayesian continuous time model for the data set data using a single layer neural network to represent the systems dynamics. \n\nkwargs\n\ntime_column_name: Name of column in data that corresponds to time. Default is \"time\".  \nhidden_units: Number of neurons in hidden layer. Default is 10.\nseed: Fixed random seed for repeatable results. Default is 1.\nproc_weight: Weight of process error omega_{proc}. Default is 1.0.\nobs_weight: Weight of observation error omega_{obs}. Default is 1.0.\nreg_weight: Weight of regularization error omega_{reg}. Default is 10^-6.\nreg_type: Type of regularization, whether \"L1\" or \"L2\" regularization. Default is \"L2\".\nl: Extrapolation parameter for forecasting. Default is 0.25.\nextrap_rho: Extrapolation parameter for forecasting. Default is 0.0.\n\n\n\n\n\n","category":"method"},{"location":"API/#UniversalDiffEq.CustomDerivatives-Tuple{Any, Any, Any}","page":"API","title":"UniversalDiffEq.CustomDerivatives","text":"CustomDerivatives(data,derivs!,initial_parameters;kwargs ... )\n\nConstructs a UDE model for the data set data  based on user defined derivatives derivs. An initial guess of model parameters are supplied with the initial_parameters argument. \n\n...\n\nArguments\n\ndata: a DataFrame object with the time of observations in a column labeled t and the remaining columns the value of the state variables at each time point. \nderivs: a Function of the form derivs!(du,u,p,t) where u is the value of the state variables, p are the model parameters, t is time, and du is updated with the value of the derivatives\ninit_parameters: A NamedTuple with the model parameters. Neural network parameters must be listed under the key NN.\n\nkwargs\n\ntime_column_name: Name of column in data that corresponds to time. Default is \"time\".\nproc_weight: Weight of process error omega_{proc}. Default is 1.0.\nobs_weight: Weight of observation error omega_{obs}. Default is 1.0.\nreg_weight: Weight of regularization error omega_{reg}. Default is 10^-6.\nreg_type: Type of regularization, whether \"L1\" or \"L2\" regularization. Default is \"L2\".\nl: Extrapolation parameter for forecasting. Default is 0.25.\nextrap_rho: Extrapolation parameter for forecasting. Default is 0.0.\n\n...\n\n\n\n\n\n","category":"method"},{"location":"API/#UniversalDiffEq.CustomDerivatives-Tuple{DataFrame, Any, Function, Any}","page":"API","title":"UniversalDiffEq.CustomDerivatives","text":"CustomDerivatives(data::DataFrame,X,derivs!::Function,initial_parameters;kwargs ... )\n\nWhen a dataframe X is supplied the model will run with covariates. the argument X should have a column for time t with the value for time in the remaining columns. The values in X will be interpolated with a linear spline for value of time not included in the data frame. \n\nWhen X is provided the derivs function must have the form derivs!(du,u,x,p,t) where x is a vector with the value of the covariates at time t. \n\nkwargs\n\ntime_column_name: Name of column in data that corresponds to time. Default is \"time\".\nvariable_column_name: Name of column in data that corresponds to the variables. Default is \"variable\".\nvalue_column_name: Name of column in data that corresponds to the covariates. Default is \"value\".\nproc_weight: Weight of process error omega_{proc}. Default is 1.0.\nobs_weight: Weight of observation error omega_{obs}. Default is 1.0.\nreg_weight: Weight of regularization error omega_{reg}. Default is 10^-6.\nreg_type: Type of regularization, whether \"L1\" or \"L2\" regularization. Default is \"L2\".\nl: Extrapolation parameter for forecasting. Default is 0.25.\nextrap_rho: Extrapolation parameter for forecasting. Default is 0.0.\n\n\n\n\n\n","category":"method"},{"location":"API/#UniversalDiffEq.CustomDerivatives-Tuple{DataFrame, Function, Any, Function}","page":"API","title":"UniversalDiffEq.CustomDerivatives","text":"CustomDerivatives(data::DataFrame,derivs!::Function,initial_parameters,priors::Function;kwargs ... )\n\nWhen a function's priors is supplied its value will be added to the loss function as a penalty term for user specified parameters. It should take the a single NamedTuple p as an argument penalties for each paramter should be calculated by accessing p with the period operator.\n\nThe prior function can be used to nudge the fitted model toward prior expectations for a parameter value. For example, the following function increases the loss when a parameter p.r has a value other than 1.5, nad a second parameter p.beta is greater than zeros. \n\nfunction priors(p)\n    l = 0.01*(p.r - 1.5)^2\n    l += 0.01*(p.beta)^2\n    return l\nend \n\nkwargs\n\ntime_column_name: Name of column in data that corresponds to time. Default is \"time\".\nproc_weight: Weight of process error omega_{proc}. Default is 1.0.\nobs_weight: Weight of observation error omega_{obs}. Default is 1.0.\nreg_weight: Weight of regularization error omega_{reg}. Default is 10^-6.\nreg_type: Type of regularization, whether \"L1\" or \"L2\" regularization. Default is \"L2\".\nl: Extrapolation parameter for forecasting. Default is 0.25.\nextrap_rho: Extrapolation parameter for forecasting. Default is 0.0.\n\n\n\n\n\n","category":"method"},{"location":"API/#UniversalDiffEq.CustomDifference-Tuple{Any, Any, Any}","page":"API","title":"UniversalDiffEq.CustomDifference","text":"CustomDifference(data,step,initial_parameters;kwrags...)\n\nConstructs a UDE model for the data set data based on user defined difference equation step. An initial guess of model parameters are supplied with the initial_parameters argument. ...\n\nArguments\n\ndata: a DataFrame object with the time of observations in a column labeled t and the remaining columns the value of the state variables at each time point. \nstep: a Function of the form step(u,t,p) where u is the value of the state variables, p are the model parameters.\ninit_parameters: A NamedTuple with the model parameters. Neural network parameters must be listed under the key NN.\n\nkwargs\n\ntime_column_name: Name of column in data that corresponds to time. Default is \"time\".\nproc_weight: Weight of process error omega_{proc}. Default is 1.0.\nobs_weight: Weight of observation error omega_{obs}. Default is 1.0.\nreg_weight: Weight of regularization error omega_{reg}. Default is 10^-6.\nreg_type: Type of regularization, whether \"L1\" or \"L2\" regularization. Default is \"L2\".\nl: Extrapolation parameter for forecasting. Default is 0.25.\nextrap_rho: Extrapolation parameter for forecasting. Default is 0.0.\n\n...\n\n\n\n\n\n","category":"method"},{"location":"API/#UniversalDiffEq.CustomDifference-Tuple{DataFrame, Any, Any, Any}","page":"API","title":"UniversalDiffEq.CustomDifference","text":"CustomDifference(data::DataFrame,X,step,initial_parameters;kwargs ... )\n\nWhen a dataframe X is supplied the model will run with covariates. the argument X should have a column for time t with the value for time in the remaining columns. The values in X will be interpolated with a linear spline for value of time not included in the data frame. \n\nWhen X is provided the step function must have the form step(u,x,t,p) where x is a vector with the value of the covariates at time t. \n\n# kwargs\n\ntime_column_name: Name of column in data that corresponds to time. Default is \"time\".\nvariable_column_name: Name of column in data that corresponds to the variables. Default is \"variable\".\nvalue_column_name: Name of column in data that corresponds to the covariates. Default is \"value\".\nproc_weight: Weight of process error omega_{proc}. Default is 1.0.\nobs_weight: Weight of observation error omega_{obs}. Default is 1.0.\nreg_weight: Weight of regularization error omega_{reg}. Default is 10^-6.\nreg_type: Type of regularization, whether \"L1\" or \"L2\" regularization. Default is \"L2\".\nl: Extrapolation parameter for forecasting. Default is 0.25.\nextrap_rho: Extrapolation parameter for forecasting. Default is 0.0.\n\n\n\n\n\n","category":"method"},{"location":"API/#UniversalDiffEq.CustomDifference-Tuple{DataFrame, Any, Any, Function}","page":"API","title":"UniversalDiffEq.CustomDifference","text":"CustomDifference(data::DataFrame,step,initial_parameters,priors::Function;kwargs ... )\n\nWhen a function's priors is supplied its value will be added to the loss function as a penalty term for user specified paramters. It should take the a single NamedTuple p as an argument penalties for each parameter should be calcualted by accessing p with the period operator. \n\nfunction priors(p)\n    l = 0.01*(p.r - 1.5)^2\n    l += 0.01*(p.beta)^2\n    return l\nend \n\nkwargs\n\ntime_column_name: Name of column in data that corresponds to time. Default is \"time\".\nproc_weight: Weight of process error omega_{proc}. Default is 1.0.\nobs_weight: Weight of observation error omega_{obs}. Default is 1.0.\nreg_weight: Weight of regularization error omega_{reg}. Default is 10^-6.\nreg_type: Type of regularization, whether \"L1\" or \"L2\" regularization. Default is \"L2\".\nl: Extrapolation parameter for forecasting. Default is 0.25.\nextrap_rho: Extrapolation parameter for forecasting. Default is 0.0.\n\n\n\n\n\n","category":"method"},{"location":"API/#UniversalDiffEq.EasyNODE-Tuple{Any, Any}","page":"API","title":"UniversalDiffEq.EasyNODE","text":"EasyNODE(data,X;kwargs ... )\n\nWhen a dataframe X is supplied the model will run with covariates. the argument X should have a column for time t with the value for time in the remaining columns. The values in X will be interpolated with a linear spline for values of time not included in the data frame. \n\nkwargs\n\ntime_column_name: Name of column in data that corresponds to time. Default is \"time\".  \nvariable_column_name: Name of column in data that corresponds to the variables. Default is \"variable\".\nvalue_column_name: Name of column in data that corresponds to the covariates. Default is \"value\".  \nhidden_units: Number of neurons in hidden layer. Default is 10.\nseed: Fixed random seed for repeatable results. Default is 1.\nproc_weight: Weight of process error omega_{proc}. Default is 1.0.\nobs_weight: Weight of observation error omega_{obs}. Default is 1.0.\nreg_weight: Weight of regularization error omega_{reg}. Default is 10^-6.\nreg_type: Type of regularization, whether \"L1\" or \"L2\" regularization. Default is \"L2\".\nl: Extrapolation parameter for forecasting. Default is 0.25.\nextrap_rho: Extrapolation parameter for forecasting. Default is 0.0.\nstep_size: Step size for ADAM optimizer. Default is 0.05.\nmaxiter: Maximum number of iterations in gradient descent algorithm. Default is 500.\nverbose: Should the training loss values be printed?. Default is false.\n\n\n\n\n\n","category":"method"},{"location":"API/#UniversalDiffEq.EasyNODE-Tuple{Any}","page":"API","title":"UniversalDiffEq.EasyNODE","text":"EasyNODE(data;kwargs ... )\n\nConstructs a pretrained continuous time model for the data set data using a single layer neural network to represent the systems dynamics. \n\nkwargs\n\ntime_column_name: Name of column in data that corresponds to time. Default is \"time\".  \nhidden_units: Number of neurons in hidden layer. Default is 10.\nseed: Fixed random seed for repeatable results. Default is 1.\nproc_weight: Weight of process error omega_{proc}. Default is 1.0.\nobs_weight: Weight of observation error omega_{obs}. Default is 1.0.\nreg_weight: Weight of regularization error omega_{reg}. Default is 10^-6.\nreg_type: Type of regularization, whether \"L1\" or \"L2\" regularization. Default is \"L2\".\nl: Extrapolation parameter for forecasting. Default is 0.25.\nextrap_rho: Extrapolation parameter for forecasting. Default is 0.0.\nstep_size: Step size for ADAM optimizer. Default is 0.05.\nmaxiter: Maximum number of iterations in gradient descent algorithm. Default is 500.\nverbose: Should the training loss values be printed?. Default is false.\n\n\n\n\n\n","category":"method"},{"location":"API/#UniversalDiffEq.EasyUDE-Tuple{Any, Any, Any}","page":"API","title":"UniversalDiffEq.EasyUDE","text":"EasyUDE(data,derivs!,initial_parameters;kwargs ... )\n\nConstructs a pretrained UDE model for the data set data  based on user defined derivatives derivs. An initial guess of model parameters are supplied with the initial_parameters argument. \n\nkwargs\n\ntime_column_name: Name of column in data that corresponds to time. Default is \"time\".\nhidden_units: Number of neurons in hidden layer. Default is 10.\nseed: Fixed random seed for repeatable results. Default is 1.\nproc_weight: Weight of process error omega_{proc}. Default is 1.0.\nobs_weight: Weight of observation error omega_{obs}. Default is 1.0.\nreg_weight: Weight of regularization error omega_{reg}. Default is 10^-6.\nreg_type: Type of regularization, whether \"L1\" or \"L2\" regularization. Default is \"L2\".\nl: Extrapolation parameter for forecasting. Default is 0.25.\nextrap_rho: Extrapolation parameter for forecasting. Default is 0.0.\nstep_size: Step size for ADAM optimizer. Default is 0.05.\nmaxiter: Maximum number of iterations in gradient descent algorithm. Default is 500.\nverbose: Should the training loss values be printed?. Default is false.\n\n\n\n\n\n","category":"method"},{"location":"API/#UniversalDiffEq.EasyUDE-Tuple{DataFrame, Any, Function, Any}","page":"API","title":"UniversalDiffEq.EasyUDE","text":"EasyUDE(data::DataFrame,X,derivs!::Function,initial_parameters;kwargs ... )\n\nWhen a dataframe X is supplied the model will run with covariates. the argument X should have a column for time t with the value for time in the remaining columns. The values in X will be interpolated with a linear spline for value of time not included in the data frame.  When X is provided the derivs function must have the form derivs!(du,u,x,p,t) where x is a vector with the value of the covariates at time t. \n\n# kwargs\n\ntime_column_name: Name of column in data that corresponds to time. Default is \"time\".  \nvariable_column_name: Name of column in data that corresponds to the variables. Default is \"variable\".\nvalue_column_name: Name of column in data that corresponds to the covariates. Default is \"value\".  \nhidden_units: Number of neurons in hidden layer. Default is 10.\nseed: Fixed random seed for repeatable results. Default is 1.\nproc_weight: Weight of process error omega_{proc}. Default is 1.0.\nobs_weight: Weight of observation error omega_{obs}. Default is 1.0.\nreg_weight: Weight of regularization error omega_{reg}. Default is 10^-6.\nreg_type: Type of regularization, whether \"L1\" or \"L2\" regularization. Default is \"L2\".\nl: Extrapolation parameter for forecasting. Default is 0.25.\nextrap_rho: Extrapolation parameter for forecasting. Default is 0.0.\nstep_size: Step size for ADAM optimizer. Default is 0.05.\nmaxiter: Maximum number of iterations in gradient descent algorithm. Default is 500.\nverbose: Should the training loss values be printed?. Default is false.\n\n\n\n\n\n","category":"method"},{"location":"API/#UniversalDiffEq.LorenzLotkaVolterra-Tuple{}","page":"API","title":"UniversalDiffEq.LorenzLotkaVolterra","text":"LorenzLotkaVolterra(;kwargs)\n\nCreate a sample dataset using the Lorenz Lotka-Volterra model as its process model:\n\n...     ```math     \frac{dx}{dt} = rx(1-\frac{x}{K}) - \u0007lpha xy + gz\n    \frac{dy}{dt} = \theta\u0007lpha xy - my\n    \frac{dz}{dt} = l(w-z)\n    \frac{dw}{dt} = z( ho-s) 0 w\n    \frac{ds}{dt} = zw-\beta s     ``...     and an observation error following a normal distribution with mean 0 and standard deviation _{obs}. ...     # kwargs     -plot: Does the function return a plot? Default istrue.     -seed: Seed for observation error to create repeatable examples. Default is123.     -datasize: Number of time steps generated. Default is60.     -T: Maximum timespan. Default is3.0.     -sigma: Standard deviation of observation error. Default is0.075`. ...\n\n\n\n\n\n","category":"method"},{"location":"API/#UniversalDiffEq.LotkaVolterra-Tuple{}","page":"API","title":"UniversalDiffEq.LotkaVolterra","text":"LotkaVolterra(;kwargs)\n\nCreate a sample dataset using the Lotka-Volterra predator-prey model as its process model:\n\n```math\n\frac{dN}{dt} = rN - \u0007lpha NP \\\n\frac{dP}{dt} = \theta\u0007lpha NP - mP\n```\n\nand an observation error following a normal distribution with mean 0 and standard deviation .\n\n# kwargs\n- `plot`: Does the function return a plot? Default is `true`.\n- `seed`: Seed for observation error to create repeatable examples. Default is `123`.\n- `datasize`: Number of time steps generated. Default is `60`.\n- `T`: Maximum timespan. Default is `3.0`.\n- `sigma`: Standard deviation of observation error. Default is `0.075`.\n\n\n\n\n\n","category":"method"},{"location":"API/#UniversalDiffEq.MultiNODE-Tuple{Any, Any}","page":"API","title":"UniversalDiffEq.MultiNODE","text":"MultiNODE(data,X;kwargs...)\n\nWhen a dataframe X is supplied the model will run with covariates. the argument X should have a column for time t with the value for time in the remaining columns. The values in X will be interpolated with a linear spline for values of time not included in the data frame. \n\n\n\n\n\n","category":"method"},{"location":"API/#UniversalDiffEq.MultiNODE-Tuple{Any}","page":"API","title":"UniversalDiffEq.MultiNODE","text":"MultiNODE(data;kwargs...)\n\nbuilds a NODE model to fit to the data. data is a DataFrame object with time arguments placed in a column labed t and a second column with a unique index for each time series. The remaining columns have observations of the state variables at each point in time and for each time series.\n\n\n\n\n\n","category":"method"},{"location":"API/#UniversalDiffEq.NNDE-Tuple{Any}","page":"API","title":"UniversalDiffEq.NNDE","text":"NNDE(data;kwargs ...)\n\nConstructs a nonparametric discrete time model for the data set data using a single layer neural network to represent the systems dynamics. \n\n# kwargs\n\ntime_column_name: Name of column in data that corresponds to time. Default is \"time\".\nhidden_units: Number of neurons in hidden layer. Default is 10.\nseed: Fixed random seed for repeatable results. Default is 1.\nproc_weight: Weight of process error omega_{proc}. Default is 1.0.\nobs_weight: Weight of observation error omega_{obs}. Default is 1.0.\nreg_weight: Weight of regularization error omega_{reg}. Default is 10^-6.\nreg_type: Type of regularization, whether \"L1\" or \"L2\" regularization. Default is \"L2\".\nl: Extrapolation parameter for forecasting. Default is 0.25.\nextrap_rho: Extrapolation parameter for forecasting. Default is 0.0.\n\n\n\n\n\n","category":"method"},{"location":"API/#UniversalDiffEq.NODE-Tuple{Any, Any}","page":"API","title":"UniversalDiffEq.NODE","text":"NODE(data,X;kwargs ... )\n\nWhen a dataframe X is supplied the model will run with covariates. the argument X should have a column for time t with the value for time in the remaining columns. The values in X will be interpolated with a linear spline for values of time not included in the data frame. \n\ntime_column_name: Name of column in data that corresponds to time. Default is \"time\".  \nvariable_column_name: Name of column in data that corresponds to the variables. Default is \"variable\".\nvalue_column_name: Name of column in data that corresponds to the covariates. Default is \"value\".  \nhidden_units: Number of neurons in hidden layer. Default is 10.\nseed: Fixed random seed for repeatable results. Default is 1.\nproc_weight: Weight of process error omega_{proc}. Default is 1.0.\nobs_weight: Weight of observation error omega_{obs}. Default is 1.0.\nreg_weight: Weight of regularization error omega_{reg}. Default is 10^-6.\nreg_type: Type of regularization, whether \"L1\" or \"L2\" regularization. Default is \"L2\".\nl: Extrapolation parameter for forecasting. Default is 0.25.\nextrap_rho: Extrapolation parameter for forecasting. Default is 0.0.\n\n\n\n\n\n","category":"method"},{"location":"API/#UniversalDiffEq.NODE-Tuple{Any}","page":"API","title":"UniversalDiffEq.NODE","text":"NODE(data;kwargs ... )\n\nConstructs a nonparametric continuous time model for the data set data using a single layer neural network to represent the systems dynamics. \n\n# kwargs\n\ntime_column_name: Name of column in data that corresponds to time. Default is \"time\".    \nhidden_units: Number of neurons in hidden layer. Default is 10.\nseed: Fixed random seed for repeatable results. Default is 1.\nproc_weight: Weight of process error omega_{proc}. Default is 1.0.\nobs_weight: Weight of observation error omega_{obs}. Default is 1.0.\nreg_weight: Weight of regularization error omega_{reg}. Default is 10^-6.\nreg_type: Type of regularization, whether \"L1\" or \"L2\" regularization. Default is \"L2\".\nl: Extrapolation parameter for forecasting. Default is 0.25.\nextrap_rho: Extrapolation parameter for forecasting. Default is 0.0.\n\n\n\n\n\n","category":"method"},{"location":"API/#UniversalDiffEq.NUTS!-Tuple{BayesianUDE}","page":"API","title":"UniversalDiffEq.NUTS!","text":" NUTS!(UDE, kwargs ...)\n\nperforms Bayesian estimation on the parameters of an UDE using the NUTS sampling algorithm.\n\nkwargs\n\ndelta: Step size used in NUTS adaptor. Default is 0.45.\nsamples: Number of parameters sampled. Default is 500.\nburnin: Number of samples used as burnin of Bayesian algorithm. Default is samples/10.\nverbose: Should the training loss values be printed?. Default is false.\n\n\n\n\n\n\n\n","category":"method"},{"location":"API/#UniversalDiffEq.SGLD!-Tuple{BayesianUDE}","page":"API","title":"UniversalDiffEq.SGLD!","text":" SGLD!(UDE, kwargs ...)\n\nPerforms Bayesian estimation on the parameters of an UDE using the SGLD sampling algorithm. At each step t, the stochastic update is provided by a random variable  with mean 0 and variance:\n\nmath a(b + t-1)^\n\nkwargs\n\na: Default is 10.0.\nb: Default is 1000.\n: Default is 0.9.\nsamples: Number of parameters sampled. Default is 500.\nburnin: Number of samples used as burnin of Bayesian algorithm. Default is samples/10.\nverbose: Should the training loss values be printed?. Default is false.\n\n\n\n\n\n\n\n","category":"method"},{"location":"API/#UniversalDiffEq.equilibrium_and_stability-NTuple{4, Any}","page":"API","title":"UniversalDiffEq.equilibrium_and_stability","text":"equilibrium_and_stability(UDE,X,lower,upper;t=0,Ntrials=100,tol=10^-3)\n\nAttempts to find all the equilibirum points for the UDE model between the upper and lower bound and return the real component of the leading eigen value to analyze stability. \n\n...\n\nkwargs\n\nt = 0: The point in time where the UDE model is evaluated, only relevant for time aware UDEs.\nNtrials = 100: the number of initializations of the root finding algorithm. \ntol = 10^-3: The threshold euclidean distance between point beyond which a new equilbirum is sufficently different to be retained. \n\n...\n\n\n\n\n\n","category":"method"},{"location":"API/#UniversalDiffEq.equilibrium_and_stability-Tuple{Any, Any, Any}","page":"API","title":"UniversalDiffEq.equilibrium_and_stability","text":"equilibrium_and_stability(UDE,lower,upper;t=0,Ntrials=100,tol=10^-3)\n\nAttempts to find all the equilibirum points for the UDE model between the upper and lower bound and return the real component of the leading eigen value to analyze stability. \n\n...\n\nkwargs\n\nt = 0: The point in time where the UDE model is evaluated, only relevant for time aware UDEs.\nNtrials = 100: the number of initializations of the root finding algorithm. \ntol = 10^-3: The threshold euclidean distance between point beyond which a new equilbirum is sufficently different to be retained. \n\n...\n\n\n\n\n\n","category":"method"},{"location":"API/#UniversalDiffEq.equilibrium_and_stability-Tuple{MultiUDE, Any, Any, Any, Any}","page":"API","title":"UniversalDiffEq.equilibrium_and_stability","text":"equilibrium_and_stability(UDE::MultiUDE,site,X,lower,upper;t=0,Ntrials=100,tol=10^-3)\n\nAttempts to find all the equilibirum points for the UDE model between the upper and lower bound and return the real component of the leading eigen value to analyze stability. \n\n...\n\nkwargs\n\nt = 0: The point in time where the UDE model is evaluated, only relevant for time aware UDEs.\nNtrials = 100: the number of initializations of the root finding algorithm. \ntol = 10^-3: The threshold euclidean distance between point beyond which a new equilbirum is sufficently different to be retained. \n\n...\n\n\n\n\n\n","category":"method"},{"location":"API/#UniversalDiffEq.forecast-Tuple{BayesianUDE, AbstractVector, AbstractVector}","page":"API","title":"UniversalDiffEq.forecast","text":"forecast(UDE::BayesianUDE, u0::AbstractVector{}, times::AbstractVector{}; summarize = true, ci = 95)\n\npredictions from the trained model UDE starting at u0 saving values at times at each individual sampled parameter. Assumes u0 is the value at time times[1]\n\nIf summarize is true, this function returns the median prediction as well as the ci% lower and upper confidence intervals. Othwerise, it returns all the individual predictions for each sampled parameter.\n\n\n\n\n\n","category":"method"},{"location":"API/#UniversalDiffEq.forecast-Tuple{BayesianUDE, AbstractVector, Real, AbstractVector}","page":"API","title":"UniversalDiffEq.forecast","text":"forecast(UDE::BayesianUDE, u0::AbstractVector{}, t0::Real, times::AbstractVector{}; summarize = true, ci = 95)\n\npredictions from the trained model UDE starting at u0 saving values at times at each individual sampled parameter. Assumes u0 occurs at time t0 and times are all larger than t0.\n\nIf summarize is true, this function returns the median prediction as well as the ci% lower and upper confidence intervals. Othwerise, it returns all the individual predictions for each sampled parameter.\n\n\n\n\n\n","category":"method"},{"location":"API/#UniversalDiffEq.forecast-Tuple{UDE, AbstractVector, AbstractVector}","page":"API","title":"UniversalDiffEq.forecast","text":"forecast(UDE::UDE, u0::AbstractVector{}, times::AbstractVector{})\n\nPredictions from the trained UDE model starting at u0 and saving values at times. Assumes u0 is the value at initial time times[1]\n\n\n\n\n\n","category":"method"},{"location":"API/#UniversalDiffEq.forecast-Tuple{UDE, AbstractVector, Real, AbstractVector}","page":"API","title":"UniversalDiffEq.forecast","text":"forecast(UDE::UDE, u0::AbstractVector{}, t0::Real, times::AbstractVector{})\n\npredictions from the trained model UDE starting at u0 saving values at times. Assumes u0 occurs at time t0 and times are all larger than t0.\n\n\n\n\n\n","category":"method"},{"location":"API/#UniversalDiffEq.get_NN_parameters-Tuple{UDE}","page":"API","title":"UniversalDiffEq.get_NN_parameters","text":"get_NN_parameters(UDE::UDE)\n\nReturns the values of the weights and biases of the neural network.\n\n\n\n\n\n","category":"method"},{"location":"API/#UniversalDiffEq.get_parameters-Tuple{UDE}","page":"API","title":"UniversalDiffEq.get_parameters","text":"get_parameters(UDE::UDE)\n\nReturns model parameters.\n\n\n\n\n\n","category":"method"},{"location":"API/#UniversalDiffEq.get_right_hand_side-Tuple{UDE}","page":"API","title":"UniversalDiffEq.get_right_hand_side","text":"get_right_hand_side(UDE::UDE)\n\nReturns the right-hand side of the differential equation (or difference equation) used to build the process model.\n\nThe function will take the state vector u and time t if the model does not include covariates. If covariates are included, then the arguments are the state vector u , covariates vector x, and time t.\n\n\n\n\n\n","category":"method"},{"location":"API/#UniversalDiffEq.gradient_descent!-Tuple{Any}","page":"API","title":"UniversalDiffEq.gradient_descent!","text":" gradient_descent!(UDE, kwargs ...)\n\nMinimizes the loss function of the UDE model with the gradient descent algorithm with a step size of step_size and a maximum number of iterations of maxiter. Prints the value of the loss function after each iteration when maxiter is true.   \n\nkwargs\n\nstep_size: Step size for ADAM optimizer. Default is 0.05.\nmaxiter: Maximum number of iterations in gradient descent algorithm. Default is 500.\nverbose: Should the training loss values be printed?. Default is false.\n\n\n\n\n\n\n\n","category":"method"},{"location":"API/#UniversalDiffEq.kfold_cv-Tuple{UDE}","page":"API","title":"UniversalDiffEq.kfold_cv","text":"kfold_cv(model::UDE; kwargs ...)\n\nRuns K fold leave future out cross validation and returns the mean squared forecasting error and a plot to visualize the model fits.\n\n...\n\nArguments\n\nmodel - a UDE model object k=10 - the number of testing and taining data sets to build leaveout=5 - the number of data points to leave out in each testingdata set BFGS = false - use the BFGS algorithm to train the model stepsize = 0.05 - step size for first run of the ADAM algorithm  maxiter = 500 - maximum iterations for first trial of ADAM step_size2 = 0.01 - step size for second iteration of ADAM, only used of BFGS is false maxiter2 = 500 - step size for second iteration of ADAM, only used of BFGS is false ...\n\n\n\n\n\n","category":"method"},{"location":"API/#UniversalDiffEq.leave_future_out_cv-Tuple{UDE}","page":"API","title":"UniversalDiffEq.leave_future_out_cv","text":"leave_future_out_cv(model::UDE; kwargs ...)\n\nRuns K fold leave future out cross validation and returns the mean squared forecasting error and a plot to visualize the model fits.\n\n...\n\nArguments\n\nmodel - the UDE model to test forecastlength = 5 - The number of data points to forecast forecastnumber = 10 - The number of trainin gnad testing data sets to create spacing = 2 - The number of data points to skip between the end of each new triaining data set BFGS=false - use BFGS algorithm to train the model stepsize = 0.05 - step size for first run of the ADAM algorithm  maxiter = 500 - maximum iterations for first trial of ADAM stepsize2 = 0.01 - step size for second iteration of ADAM, only used of BFGS is false maxiter2 = 500 - step size for second iteration of ADAM, only used of BFGS is false ...\n\n\n\n\n\n","category":"method"},{"location":"API/#UniversalDiffEq.phase_plane-Tuple{UDE, AbstractArray}","page":"API","title":"UniversalDiffEq.phase_plane","text":"phase_plane(UDE::UDE, u0s::AbstractArray; idx=[1,2],T = 100)\n\nPlots the trajectory of state variables as forecasted by the model. Runs a forecast for each provided initial condition out to T timesteps. Change the state variables that are plotted by changing idx such that it equals the indexes of the desired state variables as they appear in the data.\n\n\n\n\n\n","category":"method"},{"location":"API/#UniversalDiffEq.phase_plane-Tuple{UDE}","page":"API","title":"UniversalDiffEq.phase_plane","text":"phase_plane(UDE::UDE; idx=[1,2], u1s=-5:0.25:5, u2s=-5:0.25:5, u3s = 0, T = 100)\n\nPlots the trajectory of state variables as forecasted by the model. Runs a forecast for each permutation of u1 and u2 out to T timesteps. Change the state variables that are plotted by changing idx such that it equals the indexes of the desired state variables as they appear in the data.\n\n\n\n\n\n","category":"method"},{"location":"API/#UniversalDiffEq.phase_plane_3d-Tuple{UDE}","page":"API","title":"UniversalDiffEq.phase_plane_3d","text":"phase_plane_3d(UDE::UDE; idx=[1,2,3], u1s=-5:0.25:5, u2s=-5:0.25:5, u3s=-5:0.25:5, T = 100)\n\nThe same as phase_plane(), but displays three dimensions/state variables instead of two.\n\n\n\n\n\n","category":"method"},{"location":"API/#UniversalDiffEq.plot_forecast-Tuple{BayesianUDE, DataFrame}","page":"API","title":"UniversalDiffEq.plot_forecast","text":"plot_forecast(UDE::BayesianUDE, test_data::DataFrame)\n\nPlots the models forecast over the range of the test_data along with the value of the test data including the median prediction as well as the ci% lower and upper confidence intervals.\n\n\n\n\n\n","category":"method"},{"location":"API/#UniversalDiffEq.plot_forecast-Tuple{BayesianUDE, Int64}","page":"API","title":"UniversalDiffEq.plot_forecast","text":"plot_forecast(UDE::BayesianUDE, T::Int)\n\nPlots the models forecast up to T time steps into the future from the last observation including the median prediction as well as the ci% lower and upper confidence intervals.\n\n\n\n\n\n","category":"method"},{"location":"API/#UniversalDiffEq.plot_forecast-Tuple{UDE, DataFrame}","page":"API","title":"UniversalDiffEq.plot_forecast","text":"plot_forecast(UDE::UDE, test_data::DataFrame)\n\nPlots the model's forecast over the range of the test data along with the value of the test data.\n\n\n\n\n\n","category":"method"},{"location":"API/#UniversalDiffEq.plot_forecast-Tuple{UDE, Int64}","page":"API","title":"UniversalDiffEq.plot_forecast","text":"plot_forecast(UDE::UDE, T::Int)\n\nPlots the model's forecast up to T time steps into the future from the last observation.\n\n\n\n\n\n","category":"method"},{"location":"API/#UniversalDiffEq.plot_predictions-Tuple{BayesianUDE}","page":"API","title":"UniversalDiffEq.plot_predictions","text":"plot_predictions(UDE::BayesianUDE;ci=95)\n\nPlots the correspondence between the observed state transitons and the predicitons for the model UDE with a confidence interval ci.\n\n\n\n\n\n","category":"method"},{"location":"API/#UniversalDiffEq.plot_predictions-Tuple{UDE, DataFrame}","page":"API","title":"UniversalDiffEq.plot_predictions","text":"plot_predictions(UDE::UDE, test_data::DataFrame)\n\nPlots the correspondence between the observed state transitions in test data and the predictions from the UDE model.\n\n\n\n\n\n","category":"method"},{"location":"API/#UniversalDiffEq.plot_predictions-Tuple{UDE}","page":"API","title":"UniversalDiffEq.plot_predictions","text":"plot_predictions(UDE::UDE)\n\nPlots the correspondence between the observed state transitions and the predictions from the UDE model.\n\n\n\n\n\n","category":"method"},{"location":"API/#UniversalDiffEq.plot_state_estimates-Tuple{UDE}","page":"API","title":"UniversalDiffEq.plot_state_estimates","text":"plot_state_estimates(UDE::UDE)\n\nPlots the values of the state variables estimated by the UDE model.\n\n\n\n\n\n","category":"method"},{"location":"API/#UniversalDiffEq.predict-Tuple{BayesianUDE, DataFrame}","page":"API","title":"UniversalDiffEq.predict","text":"predict(UDE::BayesianUDE,test_data::DataFrame;summarize = true,ci = 95,df = true)\n\nUses the Bayesian UDE UDE to predict the state of the data test_data for each of the sampled parameters in training.\n\nIf summarize is true, this function returns the median prediction as well as the ci% lower and upper confidence intervals. Othwerise, it returns all the individual predictions for each sampled parameter.\n\nIf df is true, this function returns a DataFrame object. Otherwise, it returns an Array with the predictions.\n\n\n\n\n\n","category":"method"},{"location":"API/#UniversalDiffEq.print_parameter_estimates-Tuple{UDE}","page":"API","title":"UniversalDiffEq.print_parameter_estimates","text":"print_parameter_estimates(UDE::UDE)\n\nPrints the values of the known dynamics parameters estimated by the UDE model.\n\n\n\n\n\n","category":"method"},{"location":"API/#UniversalDiffEq.vectorfield_and_nullclines-Tuple{Any}","page":"API","title":"UniversalDiffEq.vectorfield_and_nullclines","text":"vectorfieldandnullclines(UDE; kwargs)\n\nCalculate the vector field and nullclines of the 2D UDE model and returns their plot.\n\nkwargs\n\n-t: Time step t at which the vector field and nullclines are calculated. Default is 0. -n: Number of elements per axes to evaluate vector field at. Default is 15. -lower: Lower limits of vector field and nullclines. Default is [0.0,0.0]. -upper: Upper limits of vector field and nullclines. Default is [1.0,1.0]. -arrowlength: Arrow size of vector field plot. Default is 2. -arrow_color: Arrow color of vector field plot. Default is grey. -xlabel: X-label of vector field plot. Default is u1. -ylabel: Y-label of vector field plot. Default is u2. -title: Plot title. Default is Vector field. -color_u1: Color of nullcline in x-axis. Default is \"red\". -color_u2: Color of nullcline in y-axis. Default is \"black\". -legend: Position of legends of nullcines in plot. Default is :outerright.\n\n\n\n\n\n","category":"method"},{"location":"BayesianModels/#Bayesian-Models","page":"Bayesian Models","title":"Bayesian Models","text":"","category":"section"},{"location":"BayesianModels/","page":"Bayesian Models","title":"Bayesian Models","text":"UniversalDiffEq.jl provides training algorithms for uncertainty quantification in NODEs and UDEs using Bayesian NODEs and UDEs. UniversalDiffEq.jl currently supports the classical No-U-Turn Sampling (NUTS) and the Stochastic Gradient Langevin Dynamics (SGLD) algorithms. These algorithms are available for the BayesianUDE constructor. This constructor can be created using the BayesianNODE and BayesianCustomDerivatives functions. These functions follow the same structure as their non-Bayesian versions NODE and CustomDerivatives.","category":"page"},{"location":"BayesianModels/","page":"Bayesian Models","title":"Bayesian Models","text":"UniversalDiffEq.BayesianNODE(data;kwargs ... )\nUniversalDiffEq.BayesianNODE(data,X;kwargs ... )\nUniversalDiffEq.BayesianCustomDerivatives(data::DataFrame,derivs!::Function,initial_parameters;kwargs ... )\nUniversalDiffEq.BayesianCustomDerivatives(data::DataFrame,X,derivs!::Function,initial_parameters;kwargs ... )","category":"page"},{"location":"BayesianModels/#UniversalDiffEq.BayesianNODE-Tuple{Any}-BayesianModels","page":"Bayesian Models","title":"UniversalDiffEq.BayesianNODE","text":"BayesianNODE(data;kwargs ... )\n\nConstructs a Bayesian continuous time model for the data set data using a single layer neural network to represent the systems dynamics. \n\nkwargs\n\ntime_column_name: Name of column in data that corresponds to time. Default is \"time\".  \nhidden_units: Number of neurons in hidden layer. Default is 10.\nseed: Fixed random seed for repeatable results. Default is 1.\nproc_weight: Weight of process error omega_{proc}. Default is 1.0.\nobs_weight: Weight of observation error omega_{obs}. Default is 1.0.\nreg_weight: Weight of regularization error omega_{reg}. Default is 10^-6.\nreg_type: Type of regularization, whether \"L1\" or \"L2\" regularization. Default is \"L2\".\nl: Extrapolation parameter for forecasting. Default is 0.25.\nextrap_rho: Extrapolation parameter for forecasting. Default is 0.0.\n\n\n\n\n\n","category":"method"},{"location":"BayesianModels/#UniversalDiffEq.BayesianNODE-Tuple{Any, Any}-BayesianModels","page":"Bayesian Models","title":"UniversalDiffEq.BayesianNODE","text":"BayesianNODE(data,X;kwargs ... )\n\nWhen a dataframe X is supplied the model will run with covariates. the argument X should have a column for time t with the value for time in the remaining columns. The values in X will be interpolated with a linear spline for values of time not included in the data frame. \n\nkwargs\n\ntime_column_name: Name of column in data that corresponds to time. Default is \"time\".  \nvariable_column_name: Name of column in data that corresponds to the variables. Default is \"variable\".\nvalue_column_name: Name of column in data that corresponds to the covariates. Default is \"value\".  \nhidden_units: Number of neurons in hidden layer. Default is 10.\nseed: Fixed random seed for repeatable results. Default is 1.\nproc_weight: Weight of process error omega_{proc}. Default is 1.0.\nobs_weight: Weight of observation error omega_{obs}. Default is 1.0.\nreg_weight: Weight of regularization error omega_{reg}. Default is 10^-6.\nreg_type: Type of regularization, whether \"L1\" or \"L2\" regularization. Default is \"L2\".\nl: Extrapolation parameter for forecasting. Default is 0.25.\nextrap_rho: Extrapolation parameter for forecasting. Default is 0.0.\n\n\n\n\n\n","category":"method"},{"location":"BayesianModels/#UniversalDiffEq.BayesianCustomDerivatives-Tuple{DataFrame, Function, Any}-BayesianModels","page":"Bayesian Models","title":"UniversalDiffEq.BayesianCustomDerivatives","text":"BayesianCustomDerivatives(data::DataFrame,derivs!::Function,initial_parameters;kwargs ... )\n\nConstructs a Bayesian UDE model for the data set data  based on user defined derivatives derivs. An initial guess of model parameters are supplied with the initial_parameters argument. \n\n...\n\nArguments\n\ndata: a DataFrame object with the time of observations in a column labeled t and the remaining columns the value of the state variables at each time point. \nderivs: a Function of the form derivs!(du,u,p,t) where u is the value of the state variables, p are the model parameters, t is time, and du is updated with the value of the derivatives\ninit_parameters: A NamedTuple with the model parameters. Neural network parameters must be listed under the key NN.\n\nkwargs\n\ntime_column_name: Name of column in data that corresponds to time. Default is \"time\".  \nhidden_units: Number of neurons in hidden layer. Default is 10.\nseed: Fixed random seed for repeatable results. Default is 1.\nproc_weight: Weight of process error omega_{proc}. Default is 1.0.\nobs_weight: Weight of observation error omega_{obs}. Default is 1.0.\nreg_weight: Weight of regularization error omega_{reg}. Default is 10^-6.\nreg_type: Type of regularization, whether \"L1\" or \"L2\" regularization. Default is \"L2\".\nl: Extrapolation parameter for forecasting. Default is 0.25.\nextrap_rho: Extrapolation parameter for forecasting. Default is 0.0.\n\n...\n\n\n\n\n\n","category":"method"},{"location":"BayesianModels/#UniversalDiffEq.BayesianCustomDerivatives-Tuple{DataFrame, Any, Function, Any}-BayesianModels","page":"Bayesian Models","title":"UniversalDiffEq.BayesianCustomDerivatives","text":"BayesianCustomDerivatives(data::DataFrame,X,derivs!::Function,initial_parameters;kwargs ... )\n\nWhen a dataframe X is supplied the model will run with covariates. the argument X should have a column for time t with the value for time in the remaining columns. The values in X will be interpolated with a linear spline for value of time not included in the data frame. \n\nWhen X is provided the derivs function must have the form derivs!(du,u,x,p,t) where x is a vector with the value of the covariates at time t. \n\nkwargs\n\ntime_column_name: Name of column in data that corresponds to time. Default is \"time\".  \nvariable_column_name: Name of column in data that corresponds to the variables. Default is \"variable\".\nvalue_column_name: Name of column in data that corresponds to the covariates. Default is \"value\".  \nhidden_units: Number of neurons in hidden layer. Default is 10.\nseed: Fixed random seed for repeatable results. Default is 1.\nproc_weight: Weight of process error omega_{proc}. Default is 1.0.\nobs_weight: Weight of observation error omega_{obs}. Default is 1.0.\nreg_weight: Weight of regularization error omega_{reg}. Default is 10^-6.\nreg_type: Type of regularization, whether \"L1\" or \"L2\" regularization. Default is \"L2\".\nl: Extrapolation parameter for forecasting. Default is 0.25.\nextrap_rho: Extrapolation parameter for forecasting. Default is 0.0.\n\n\n\n\n\n","category":"method"},{"location":"BayesianModels/#Training-of-Bayesian-UDEs","page":"Bayesian Models","title":"Training of Bayesian UDEs","text":"","category":"section"},{"location":"BayesianModels/","page":"Bayesian Models","title":"Bayesian Models","text":"Instead of training Bayesian UDEs using the gradient_descent! and BFGS! functions, we use the algorithms for Bayesian optimization. We repeat the tutorial for regular UDEs but create a BayesianUDE using BayesianCustomDerivatives instead of CustomDerivatives.","category":"page"},{"location":"BayesianModels/","page":"Bayesian Models","title":"Bayesian Models","text":"using UniversalDiffEq, DataFrames, Lux, Random\n\ndata, plt = LotkaVolterra()\ndims_in = 2\nhidden_units = 10\nnonlinearity = tanh\ndims_out = 1\nNN = Lux.Chain(Lux.Dense(dims_in,hidden_units,nonlinearity),\n        Lux.Dense(hidden_units,dims_out))\n\n# initialize the neural network states and parameters \nrng = Random.default_rng() \nNNparameters, states = Lux.setup(rng,NN) \n\nfunction lotka_volterra_derivs!(du,u,p,t)\n    C, states = NN(u,p.NN,states) \n    du[1] = p.r*u[1] - C[1]\n    du[2] = p.theta*C[1] -p.m*u[2]\nend\n\ninitial_parameters = (NN = NNparameters, r = 1.0, m = 0.5, theta = 0.5)\nmodel = BayesianCustomDerivatives(data,lotka_volterra_derivs!,initial_parameters)","category":"page"},{"location":"BayesianModels/","page":"Bayesian Models","title":"Bayesian Models","text":"Training is then done using NUTS! or SGLD!:","category":"page"},{"location":"BayesianModels/","page":"Bayesian Models","title":"Bayesian Models","text":"NUTS!(model,samples = 500)","category":"page"},{"location":"BayesianModels/","page":"Bayesian Models","title":"Bayesian Models","text":"NUTS!(UDE::BayesianUDE;kwargs ...)\nSGLD!(UDE::BayesianUDE;kwargs ...)","category":"page"},{"location":"BayesianModels/#UniversalDiffEq.NUTS!-Tuple{BayesianUDE}-BayesianModels","page":"Bayesian Models","title":"UniversalDiffEq.NUTS!","text":" NUTS!(UDE, kwargs ...)\n\nperforms Bayesian estimation on the parameters of an UDE using the NUTS sampling algorithm.\n\nkwargs\n\ndelta: Step size used in NUTS adaptor. Default is 0.45.\nsamples: Number of parameters sampled. Default is 500.\nburnin: Number of samples used as burnin of Bayesian algorithm. Default is samples/10.\nverbose: Should the training loss values be printed?. Default is false.\n\n\n\n\n\n\n\n","category":"method"},{"location":"BayesianModels/#UniversalDiffEq.SGLD!-Tuple{BayesianUDE}-BayesianModels","page":"Bayesian Models","title":"UniversalDiffEq.SGLD!","text":" SGLD!(UDE, kwargs ...)\n\nPerforms Bayesian estimation on the parameters of an UDE using the SGLD sampling algorithm. At each step t, the stochastic update is provided by a random variable  with mean 0 and variance:\n\nmath a(b + t-1)^\n\nkwargs\n\na: Default is 10.0.\nb: Default is 1000.\n: Default is 0.9.\nsamples: Number of parameters sampled. Default is 500.\nburnin: Number of samples used as burnin of Bayesian algorithm. Default is samples/10.\nverbose: Should the training loss values be printed?. Default is false.\n\n\n\n\n\n\n\n","category":"method"},{"location":"BayesianModels/","page":"Bayesian Models","title":"Bayesian Models","text":"The other functions for model analysis have methods for the BayesianUDE constructor:","category":"page"},{"location":"BayesianModels/","page":"Bayesian Models","title":"Bayesian Models","text":"predict(UDE::BayesianUDE,test_data::DataFrame;summarize = true,ci = 95,df = true)","category":"page"},{"location":"BayesianModels/#UniversalDiffEq.predict-Tuple{BayesianUDE, DataFrame}-BayesianModels","page":"Bayesian Models","title":"UniversalDiffEq.predict","text":"predict(UDE::BayesianUDE,test_data::DataFrame;summarize = true,ci = 95,df = true)\n\nUses the Bayesian UDE UDE to predict the state of the data test_data for each of the sampled parameters in training.\n\nIf summarize is true, this function returns the median prediction as well as the ci% lower and upper confidence intervals. Othwerise, it returns all the individual predictions for each sampled parameter.\n\nIf df is true, this function returns a DataFrame object. Otherwise, it returns an Array with the predictions.\n\n\n\n\n\n","category":"method"},{"location":"BayesianModels/","page":"Bayesian Models","title":"Bayesian Models","text":"plot_predictions(UDE::BayesianUDE;ci=95)","category":"page"},{"location":"BayesianModels/#UniversalDiffEq.plot_predictions-Tuple{BayesianUDE}-BayesianModels","page":"Bayesian Models","title":"UniversalDiffEq.plot_predictions","text":"plot_predictions(UDE::BayesianUDE;ci=95)\n\nPlots the correspondence between the observed state transitons and the predicitons for the model UDE with a confidence interval ci.\n\n\n\n\n\n","category":"method"},{"location":"BayesianModels/","page":"Bayesian Models","title":"Bayesian Models","text":"plot_forecast(UDE::BayesianUDE, T::Int;ci = 95)","category":"page"},{"location":"BayesianModels/#UniversalDiffEq.plot_forecast-Tuple{BayesianUDE, Int64}-BayesianModels","page":"Bayesian Models","title":"UniversalDiffEq.plot_forecast","text":"plot_forecast(UDE::BayesianUDE, T::Int)\n\nPlots the models forecast up to T time steps into the future from the last observation including the median prediction as well as the ci% lower and upper confidence intervals.\n\n\n\n\n\n","category":"method"},{"location":"BayesianModels/","page":"Bayesian Models","title":"Bayesian Models","text":"plot_forecast(UDE::BayesianUDE, test_data::DataFrame;ci = 95)","category":"page"},{"location":"BayesianModels/#UniversalDiffEq.plot_forecast-Tuple{BayesianUDE, DataFrame}-BayesianModels","page":"Bayesian Models","title":"UniversalDiffEq.plot_forecast","text":"plot_forecast(UDE::BayesianUDE, test_data::DataFrame)\n\nPlots the models forecast over the range of the test_data along with the value of the test data including the median prediction as well as the ci% lower and upper confidence intervals.\n\n\n\n\n\n","category":"method"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/#Using-time-dependent-NODEs-to-predict-regime-changes","page":"Examples","title":"Using time-dependent NODEs to predict regime changes","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"One interesting use of NODE and UDE models in ecology is detecting and predicting regime changes, sudden shifts in the structure and function of an ecosystem caused by a small change in conditions. Regime changes are caused by the interaction of non-linear feedback mechanisms, environmental variability, and long-term environmental change. NODE and UDE models built with UniversalDiffEq.jl can capture all three of these processes, opening up the possibility of detecting and predicting regime changes from data.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"In the following example, we build a NODE model for a two-species system that undergoes a regime change. The data are simulated from the Mumby et al. (2007) model of coral-algae competition with an added term for stochastic coral mortality events and a long-term increase in the coral mortality rate from increasing temperature. The increasing temperature eventually causes the system to shift from a coral-dominated to an algae-dominated state (Fig. 1). The data from the time of the regime change are used to fit the model.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: Figure 1: simulated regime change data )","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The model is a function of the area covered by coral p_C and algae p_A, an environmental covariate X that is related to coral mortality and time t to capture the effect of the slowly increasing coral mortality rate. The coral and macroalgae abundances are transformed to x_i = softmax^-1(p_i) using the inverse softmax transformation before fitting the model","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"   fracdx_Cdt = NN_1(x_Cx_AXt) \n   fracdx_Adt = NN_2(x_Cx_AXt) ","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"UniversalDiffEq.jl does not have built-in methods to construct time-dependent NODEs, but they can be built easily using the CustomDerivatives function. In this case, we initialize a neural network that takes four inputs (one each for coral cover, algae cover, the environmental covariate, and time) and two outputs using Lux.jl. The derivatives function derivs! divides time by 50 to match the scale of the other inputs; then concatenates the abundances of each species, the covariate X, and time into a vector; and finally evaluates the neural network. The UDE model is constructed using the CustomDerivatives function, passing both the species data in a data frame called data and the covariate in a data frame called X.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using Lux, UniversalDiffEq\n# set neural network dimensions\ndims_in = 4\ndims_out = 2\nhidden = 10\n\n\n# Define neural network with Lux.jl\nNN = Lux.Chain(Lux.Dense(dims_in, hidden, tanh), Lux.Dense(hidden, dims_out))\nrng = Random.default_rng()\nNNparameters, NNstates = Lux.setup(rng,NN)\nparameters = (NN = NNparameters,)\n\n\n# Define derivatives (time dependent NODE)\nfunction derivs!(du,u,X,p,t)\n    vals = NN([u[1],u[2],X[1],t/50-1.0],p.NN,NNstates)[1]\n    du[1] = vals[1]\n    du[2] = vals[2]\n    return du\nend\n\nmodel = UniversalDiffEq.CustomDerivatives(data[1:80,:],X,derivs!,parameters;proc_weight=2.5,obs_weight=10.0,reg_weight=10^-2.5)\n\ngradient_descent!(model, verbose = true, maxiter = 500)\ngradient_descent!(model, verbose = true, maxiter = 500, step_size = 0.01)\nnothing","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We can use the plot_state_estimates and plot_predictions functions to test the fit of the model to the training data.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"UniversalDiffEq.plot_state_estimates(model)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"UniversalDiffEq.plot_predictions(model)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Unsurprisingly, given that this is simulated data, our model was able to fit the training data very closely.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Given that the model fits the data well, we can move on to our analysis. The goal of this model is to capture the effects of a slowly changing variable on the dynamics of the coral-algae system. In particular, we want to identify any potential regime changes, points in time where a small change in the environment leads to a large change in the state of the ecosystem. Often, regime changes are characterized by the appearance or disappearance of equilibrium points in a dynamical system. We can identify these events by tracking changes in the derivatives function of the NODE model over time. This function is the right-hand side of a system of ODEs and, therefore, can be analyzed for equilibrium points and their stability. Because the NODE model is time-dependent, new equilibria may appear or existing ones may change their stability creating a regime change.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"To identify regime changes, we can extract the right-hand side of the ODE from the fitted model using the get_right_hand_side function. In the following example, we use the derivatives function RHS to plot a vector field for the coral and macroalgae at four points in time.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using Plots\np1 = vectorfield_and_nullclines(model,[0.0];t = 0, n = 15, lower = [-2.0,-2.0], upper = [2.0,2.0])\np2 = vectorfield_and_nullclines(model,[0.0];t = 70, n = 15, lower = [-2.0,-2.0], upper = [2.0,2.0])\np3 = vectorfield_and_nullclines(model,[0.0];t = 100, n = 15, lower = [-2.0,-2.0], upper = [2.0,2.0])\np4 = vectorfield_and_nullclines(model,[0.0];t = 130, n = 15, lower = [-2.0,-2.0], upper = [2.0,2.0])\nplt = plot(p1,p2,p3,p4)\nsavefig(plt,\"../docs/src/figures/regiem_changes_vector plots.png\")\nplt","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The vector plots show clear changes in the dynamics of the system over time that likely constitute a regime change from a coral-dominated state an algae-dominated state. For small values of time, the vector fields all point to the upper left, which is high coral abundance and low algae abundance. Over time, however, a second equilibrium appears in the lower right: low coral and high algae abundance. The final vector field, t = 130, predicts 50 years into the future after the end of the time series. This plot predicts that the basin of attraction around the algae-dominated state will continue to grow, which is consistent with the data, and shows a sudden switch from high coral to high algae abundance.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We can also illustrate the regime shift in the system by plotting the equilibrium coral and algae abundances for different values of time using the equilibrium_and_stability function. The following code block uses equilibrium_and_stability to calculate the equilibrium point of the model at each point in time and colors stable equilibrium points black and unstable equilibrium points white. This analysis shows the coral-dominated equilibrium bifurcating into two equilibrium points after time 120. Some additional equilibrium points are also identified over time.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"p1 = Plots.plot(ylims = (-2.5,2.0), ylabel = \"Coral\")\np2 = Plots.plot(ylims = (-2.5,2.0), xlabel = \"Time\", ylabel = \"Algae\")\nfor t in 1:2:180\n    print(t,\" \")\n    eqs,evals = equilibrium_and_stability(model,[0.0],[-2.0,-2.0],[2.0,2.0];t=t,Ntrials=50)\n\n    for i in eachindex(eqs)\n        col = \"white\"\n        if evals[i] < 0\n            col = \"black\"\n        end\n        Plots.scatter!(p1,[t],eqs[i][2:2],color=col, label = \"\")\n        Plots.scatter!(p2,[t],eqs[i][1:1],color=col, label = \"\")\n    end\nend\nplt=Plots.plot(p1,p2,layout = (2,1))\nsavefig(plt,\"../docs/src/figures/regiem_changes_bifrucation_plot.png\")\nplt","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/#Using-UDEs-to-learn-the-dynamics-of-coupled-human-natural-systems","page":"Examples","title":"Using UDEs to learn the dynamics of coupled human-natural systems","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Natural resources like fisheries are examples of coupled human and natural systems; human activities influence the state of the natural system, and the environment influences human activities. One of the primary goals of coupled human-natural systems research is understanding how these cycles of mutual causation determine biological and social outcomes. We may also wish to understand how interventions from regulators modify interactions between people and their environment to identify if these interventions achieve their desired effects.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"In this example, we build a UDE model to describe how the interactions between a fishing fleet and the exploited population change before and after the government limits entry into the fishery and predict the counterfactual outcomes in the absence of regulation.","category":"page"},{"location":"examples/#Data:-US-West-Coast-Cow-Cod-Fishery","page":"Examples","title":"Data: US West Coast Cow Cod Fishery","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"For this example, we use data from groundfish fisheries on the West Coast of the United States. These fisheries were managed under an open-access framework until 1992 when entry into the fishery was restricted following large declines in catch and abundance. We gathered data on the stock biomass B (proxy for abundance) and harvest H from the RAM legacy database and coded the change in regulations using binary variable I_LE that switched from zero to one in 1992 when limited entry regulations began. The time series of these three variables are shown below.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using CSV, Plots, DataFrames\ndata = CSV.read(\"CowCodFishery.csv\",DataFrame)\nplt = Plots.scatter(data.t,data.y, label = \"log Abundance\", xlabel = \"Time\", ylabel = \"value\", width = 2)\nPlots.scatter!(data.t,data.H, label = \"Harvest\", width = 2)\nPlots.scatter!(data.t,data.limited_entry, label = \"Limited entry\", width = 2)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/#Model","page":"Examples","title":"Model","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"We use a logistic growth model to describe the changes in the population biomass and model changes in harvest as a function of the stock, the current harvest, and regulations. The factors that drive changes in harvest may be complex and non-linear so we use a neural network to model the rate of change of harvest. Combining these assumptions yields a system of differential equations that we fit into the data using the UniversalDiffEq.jl package","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"fracdHdt = NN(HBI_LEwb)\n\nfracdBdt = rB(1-BK) - qH","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"where r is the growth rate of the population, K is the carrying capacity, q is a scaling factor to match the units of stock biomass and harvest, w is the set of neural network weights, and b is the set of neural network biases. We define the model using a neural network from Lux.jl and the CustomDerivatives function. We fit the model parameters using the gradient descent and BFGS algorithms.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# set up neural network\nusing UniversalDiffEq, Lux, Random,\ndims_in = 3\nhidden = 10\nNN = Lux.Chain(Lux.Dense(dims_in,hidden,tanh),Lux.Dense(hidden,1))\nrng = Random.default_rng()\nNNparameters, NNstates = Lux.setup(rng,NN)\n\n# set initial parameters\ninit_parameters = (NN = NNparameters, q = 1.0, r = 0.5, K = 4.0)\n\n# Define model\nfunction derivs!(du,u,X,p,t)\n    du[1] = NN(vcat(u,X),p.NN,NNstates)[1][1] # harvest\n    du[2] = p.r*u[2]*(1-u[2]/p.K) - p.q*u[1] # logistic growth minus harvest x scaling coef\nend\n\n# organize data\nstate_variables = DataFrame(t = data.t, H = data.H, y = exp.(data.y))\ncovariates = DataFrame(t = data.t, X = data.limited_entry)\n\n# initialize model\nmodel = CustomDerivatives(state_variables,covariates,derivs!,init_parameters;proc_weight=2.0,obs_weight=0.5,reg_weight=10^-4.0)\n\n# fit the model\ngradient_descent!(model,verbose = true)\nBFGS!(model,verbos = true)\nnothing","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We can evaluate the model fit using plot_state_estimates and plot_predictions functions to compare the estimated state variables to the data and the predicted changes in state to the observed changes between time steps. The fitted model performs well by visual inspection on both metrics.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"p1 = plot_state_estimates(model)\np2 = plot_predictions(model)\nplot(p1,p2, layout= (2,1))","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/#Results:","page":"Examples","title":"Results:","text":"","category":"section"},{"location":"examples/#Counterfactual-prediction","page":"Examples","title":"Counterfactual prediction","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"We use the model to predict the harvest level and abundance of the population under limited entry and open access after 1992 when regulations were imposed. Under limited entry, the model predictions closely match historical data, with harvest decreasing and abundance increasing. Under open access conditions, the model predicts the system will approach an equilibrium with much lower abundance than observed in the historical data with harvest remaining relatively constant after 1992.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"u1991 = reshape(model.data[:,model.times .== 1991],2)\ntimes_OA = collect(1940:1972) # 22 years under open access conditions\ntimes_LE = collect(1991:2020) # 22 years under regulation\nforecast_OA = UniversalDiffEq.forecast(model,u1991, times_OA)\nforecast_LE = UniversalDiffEq.forecast(model,u1991, times_LE)\nplt = Plots.scatter(state_variables.t, state_variables.H,c=1, label = \"Catch Historical\")\nPlots.scatter!(state_variables.t,log.(state_variables.y),c=2, label = \"Abundance Historical\")\nPlots.plot!(1991 .+ forecast_OA[:,1] .- forecast_OA[1,1], forecast_OA[:,2], width = 2,c=1, label = \"Catch Counter Factual\")\nPlots.plot!(1991 .+ forecast_OA[:,1].- forecast_OA[1,1],log.(forecast_OA[:,3]), width = 2,c=2, label = \"Abundance Counter Factual\",xlabel = \"Time\", ylabel = \"(log) Biomass\")\nPlots.plot!(forecast_LE[:,1], forecast_LE[:,2], width = 2,c=1, label = \"Forecast\", linestyle = :dash)\nPlots.plot!(forecast_LE[:,1],log.(forecast_LE[:,3]), width = 2,c=2, label = \"Forecast\", xlabel = \"Time\", ylabel = \"(log) Biomass\", linestyle = :dash)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/#Dynamics-before-and-after-regulation","page":"Examples","title":"Dynamics before and after regulation","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The limited entry regulations produced a qualitative change in the dynamics of the coupled human-natural system. Prior to regulations, our model predicts the system had oscillating dynamics around a stable equilibrium. These dynamics are characteristic of the bioeconomic cycles predicted by theoretical models of open-access fisheries. When regulated, the cycling dynamics disappear and the model predicts declining harvest and increasing biomass over most of the state space.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"p1 = vectorfield_and_nullclines(model,0, upper = [0.3,4.0], arrow_color = \"blue\",legend = :none,title = \"Open Access\",xlabel = \"Harvest\", ylabel = \"Abundance\")\np2 = vectorfield_and_nullclines(model,1, upper = [0.3,4.0], arrow_color = \"blue\",legend = :topright,title = \"Limited Entry\",xlabel = \"Harvest\", ylabel = \"\")\nplt = plot(p1,p2)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"MultipleTimeSeries/#Fitting-a-model-to-multiple-time-series","page":"Fitting a model to multiple time series","title":"Fitting a model to multiple time series","text":"","category":"section"},{"location":"MultipleTimeSeries/","page":"Fitting a model to multiple time series","title":"Fitting a model to multiple time series","text":"UniversalDiffEq.jl provides a set of functions to fit models to multiple time series. The functions for this mirror the functions for fitting NODEs and UDEs to single time series with the prefix Multi. For example, to build a NODE model for multiple time series you would use the MultiNODE function. The functions for model fitting, testing, and visualization have the same names. The other important difference is the data format: a column with a unique index for each time series must be included. ","category":"page"},{"location":"MultipleTimeSeries/#Dataframe","page":"Fitting a model to multiple time series","title":"Dataframe","text":"","category":"section"},{"location":"MultipleTimeSeries/","page":"Fitting a model to multiple time series","title":"Fitting a model to multiple time series","text":"t series x1 x2\n1 1 x_11t x_12t\n2 1 x_11t x_12t\n3 1 x_11t x_12t\n1 2 x_21t x_22t\n2 2 x_21t x_22t\n3 2 x_21t x_22t","category":"page"},{"location":"MultipleTimeSeries/","page":"Fitting a model to multiple time series","title":"Fitting a model to multiple time series","text":"Covariates can be added to the models as well. The covariates data frame must have the same structure. ","category":"page"},{"location":"MultipleTimeSeries/","page":"Fitting a model to multiple time series","title":"Fitting a model to multiple time series","text":"UniversalDiffEq.MultiNODE(data;kwargs...)\nUniversalDiffEq.MultiNODE(data,X;kwargs...)","category":"page"},{"location":"MultipleTimeSeries/#UniversalDiffEq.MultiNODE-Tuple{Any}-MultipleTimeSeries","page":"Fitting a model to multiple time series","title":"UniversalDiffEq.MultiNODE","text":"MultiNODE(data;kwargs...)\n\nbuilds a NODE model to fit to the data. data is a DataFrame object with time arguments placed in a column labed t and a second column with a unique index for each time series. The remaining columns have observations of the state variables at each point in time and for each time series.\n\n\n\n\n\n","category":"method"},{"location":"MultipleTimeSeries/#UniversalDiffEq.MultiNODE-Tuple{Any, Any}-MultipleTimeSeries","page":"Fitting a model to multiple time series","title":"UniversalDiffEq.MultiNODE","text":"MultiNODE(data,X;kwargs...)\n\nWhen a dataframe X is supplied the model will run with covariates. the argument X should have a column for time t with the value for time in the remaining columns. The values in X will be interpolated with a linear spline for values of time not included in the data frame. \n\n\n\n\n\n","category":"method"},{"location":"#UniversalDiffEq.jl","page":"UniversalDiffEq.jl","title":"UniversalDiffEq.jl","text":"","category":"section"},{"location":"","page":"UniversalDiffEq.jl","title":"UniversalDiffEq.jl","text":"UniversalDiffEq.jl is a library for building state-space universal dynamic equations (SS-UDEs), nonlinear time series models that learn unknown nonlinear relationships in time series data using neural networks. The package provides model constructor functions to build discrete and continuous time models that combine known parametric functions with unknown functions represented by neural networks. UniversalkDiffEq.jl defines a set of training procedures that can simultaneously estimate the parameters of known functions and train a neural network to represent unknown functions. The models are trained using a state space modeling procedure, which makes them robust to stochastic variability and measurement errors. The package uses Lux.jl to define the neural networks and DiffEqFlux.jl to train neural networks embedded within continuous time models. ","category":"page"},{"location":"#Universal-dynamic-equations","page":"UniversalDiffEq.jl","title":"Universal dynamic equations","text":"","category":"section"},{"location":"","page":"UniversalDiffEq.jl","title":"UniversalDiffEq.jl","text":"Universal dynamic equations include two classes of models: universal differential equations and universal difference equations. Universal differential equations are continuous-time models that learn the right-hand side of a system of ordinary differential equations from time series data","category":"page"},{"location":"","page":"UniversalDiffEq.jl","title":"UniversalDiffEq.jl","text":"fracdudt = f(u)","category":"page"},{"location":"","page":"UniversalDiffEq.jl","title":"UniversalDiffEq.jl","text":"Universal difference equations are discrete-time models that learn the right-hand side of a system of difference equations","category":"page"},{"location":"","page":"UniversalDiffEq.jl","title":"UniversalDiffEq.jl","text":"u_t+1 = u_t + f(u)","category":"page"},{"location":"","page":"UniversalDiffEq.jl","title":"UniversalDiffEq.jl","text":"In the simplest case, a neural network NN represents the entire right-hand side of the model f(bfmathx) = NN(bfmathx). However, in general, the right-hand side of the model can include both neural networks and parametric functions. For example, the classic Loka Volterra predator-prey model includes a growth term for the prey rN, a mortality rate for the predator mN, and a linear interaction term between the two species alpha NP. We can use universal differential equations to build a more flexible version of this model by replacing the linear interaction term with a neural network ","category":"page"},{"location":"","page":"UniversalDiffEq.jl","title":"UniversalDiffEq.jl","text":"fracdNdt = rN - NN(NP) \nfracdPdt = theta NN(NP) - mP","category":"page"},{"location":"","page":"UniversalDiffEq.jl","title":"UniversalDiffEq.jl","text":"We can train the neural network NN and estimate the biological parameters r, m, and theta from time series data using the training routines defined in UniversalDiffEq.jl.","category":"page"},{"location":"#How-UniversalDiffEq.jl-works","page":"UniversalDiffEq.jl","title":"How UniversalDiffEq.jl works","text":"","category":"section"},{"location":"","page":"UniversalDiffEq.jl","title":"UniversalDiffEq.jl","text":"UniversalDiffEq.jl builds and trains universal dynamic equations within a state-space modeling framework. State-space models describe noisy time series data by combining two models: (1) an observation model that describes the relationship between the data and the actual underlying state of the system and (2) a process model that describes the changes in the system's state over time. This model structure allows state-space models to account for uncertainty caused by noisy observations (observation error) and inherent randomness within the system's dynamics (process error).","category":"page"},{"location":"","page":"UniversalDiffEq.jl","title":"UniversalDiffEq.jl","text":"State-space models simultaneously estimate the parameters of the process and observation models theta and the value of the state variables at each point in time hatu_t. These parameters are estimated by optimizing a loss function that combines two components: the observation loss and the process loss. The observation loss compares the state estimates to the data y_t using the observaiton model g(u_t)","category":"page"},{"location":"","page":"UniversalDiffEq.jl","title":"UniversalDiffEq.jl","text":"L_obs = frac1T sum_i = 1^T (y_t - g(hatu_ttheta ))^2","category":"page"},{"location":"","page":"UniversalDiffEq.jl","title":"UniversalDiffEq.jl","text":"The process loss compares predictions of the process model f(u_ttheta) to the estimated states variables at the next time point","category":"page"},{"location":"","page":"UniversalDiffEq.jl","title":"UniversalDiffEq.jl","text":"L_proc = frac1T-1 sum_i = 2^Tfrac1Delta t(hatu_t - f(hatu_t-1theta ))^2","category":"page"},{"location":"","page":"UniversalDiffEq.jl","title":"UniversalDiffEq.jl","text":"The process loss is weighted by the inverse of the time between data points Delta t. ","category":"page"},{"location":"","page":"UniversalDiffEq.jl","title":"UniversalDiffEq.jl","text":"In addition to the process and observaiton loss additional terms can be added to the loss funciton to regularize the neuarl network parmaters and to incorperate prior informaiton about the parameters of parametric functions","category":"page"},{"location":"","page":"UniversalDiffEq.jl","title":"UniversalDiffEq.jl","text":"L_reg = R(theta)","category":"page"},{"location":"","page":"UniversalDiffEq.jl","title":"UniversalDiffEq.jl","text":"The UniversalDiffEq.jl package combines weighted sums of these three components to create the full loss function","category":"page"},{"location":"","page":"UniversalDiffEq.jl","title":"UniversalDiffEq.jl","text":"L(hatutheta) = omega_obs L_obs + omega_proc L_proc + omega_reg L_reg","category":"page"},{"location":"","page":"UniversalDiffEq.jl","title":"UniversalDiffEq.jl","text":"UniversalDiffEq.jl uses Optimizers.jl to find the state and parameter estimates that minimize the loss function. Currently, two optimization algorithms are available, the Adam gradient descent algorithm and the quasi-Newton algorithm BFGS.","category":"page"},{"location":"#Data-types","page":"UniversalDiffEq.jl","title":"Data types","text":"","category":"section"},{"location":"","page":"UniversalDiffEq.jl","title":"UniversalDiffEq.jl","text":"UniversalDiffEq.jl can train models on individual time series y_t or panel of mutliple time series y_it from systmes with similar dynamics. Seperate model constructors are provided for models trained on single and multiple time series.UniversalDiffEq.jl even allows the model to include paramters that have duiffernt value for each time series in the training set. ","category":"page"},{"location":"","page":"UniversalDiffEq.jl","title":"UniversalDiffEq.jl","text":"UniversalDiffEq.jl can accomidate irregualrly sampled data. Data for continuous time models can be sampled at any point in time, while discrete tiem models requre and integer valued time steps between observations. UniversalDiffEq.jl does not accomidate observaitons that are missing a sub set of the state variables.","category":"page"},{"location":"","page":"UniversalDiffEq.jl","title":"UniversalDiffEq.jl","text":"Models built with UniversalDiffEq.jl can incorperate covariates X_t that influence the dynamics of the primary state variables. Discrete time models require the the observations of the covariates to match the time when the state variables are observed ","category":"page"},{"location":"#Package-Contents","page":"UniversalDiffEq.jl","title":"Package Contents","text":"","category":"section"},{"location":"","page":"UniversalDiffEq.jl","title":"UniversalDiffEq.jl","text":"Pages = [\"Models.md\", \"ModelTesting.md\",\"MultipleTimeSeries.md\",\"NutsAndBolts.md\",\"modelanalysis.md\",\"examples.md\",\"API.md\"]","category":"page"},{"location":"modelanalysis/#Model-analysis","page":"Model analysis","title":"Model analysis","text":"","category":"section"},{"location":"modelanalysis/","page":"Model analysis","title":"Model analysis","text":"UniversalDiffEq.jl provides several functions to analyze the characteristics of the fitted models. The most basic of these is the get_right_hand_side function. This function takes a UDE model as an argument and returns the right-hand side of the fitted differential or difference equation. This function can then be treated like any dynamic model and analyzed for equilibria, stability, tipping points, and other phenomena of interest.  ","category":"page"},{"location":"modelanalysis/","page":"Model analysis","title":"Model analysis","text":"UniversalDiffEq.get_right_hand_side(UDE::UDE)","category":"page"},{"location":"modelanalysis/#UniversalDiffEq.get_right_hand_side-Tuple{UDE}-modelanalysis","page":"Model analysis","title":"UniversalDiffEq.get_right_hand_side","text":"get_right_hand_side(UDE::UDE)\n\nReturns the right-hand side of the differential equation (or difference equation) used to build the process model.\n\nThe function will take the state vector u and time t if the model does not include covariates. If covariates are included, then the arguments are the state vector u , covariates vector x, and time t.\n\n\n\n\n\n","category":"method"},{"location":"modelanalysis/","page":"Model analysis","title":"Model analysis","text":"The library also has functions to evaluate model predictions. The forecast function will run a simulation of the model starting at the initial point u0 and returning the value of the state variables at each point in the times vector.  ","category":"page"},{"location":"modelanalysis/","page":"Model analysis","title":"Model analysis","text":"The function phase_plane plots forecasted trajectories of state variables for a given number of timesteps T. All phase plane functions also work with the MultiUDE model type, and plot phase planes for each series in the data.","category":"page"},{"location":"modelanalysis/","page":"Model analysis","title":"Model analysis","text":"UniversalDiffEq.phase_plane(UDE::UDE; idx=[1,2], u1s=-5.0,0.25,5.0, u2s=-5:0.25:5,u3s = 0,T = 100)\nUniversalDiffEq.phase_plane(UDE::UDE, u0s::AbstractArray; idx=[1,2],T = 100)\nUniversalDiffEq.phase_plane_3d(UDE::UDE; idx=[1,2,3], u1s=-5.0,0.25,5.0, u2s=-5:0.25:5,u3s=-5:0.25:5,T = 100)","category":"page"},{"location":"modelanalysis/#UniversalDiffEq.phase_plane-Tuple{UDE}-modelanalysis","page":"Model analysis","title":"UniversalDiffEq.phase_plane","text":"phase_plane(UDE::UDE; idx=[1,2], u1s=-5:0.25:5, u2s=-5:0.25:5, u3s = 0, T = 100)\n\nPlots the trajectory of state variables as forecasted by the model. Runs a forecast for each permutation of u1 and u2 out to T timesteps. Change the state variables that are plotted by changing idx such that it equals the indexes of the desired state variables as they appear in the data.\n\n\n\n\n\n","category":"method"},{"location":"modelanalysis/#UniversalDiffEq.phase_plane-Tuple{UDE, AbstractArray}-modelanalysis","page":"Model analysis","title":"UniversalDiffEq.phase_plane","text":"phase_plane(UDE::UDE, u0s::AbstractArray; idx=[1,2],T = 100)\n\nPlots the trajectory of state variables as forecasted by the model. Runs a forecast for each provided initial condition out to T timesteps. Change the state variables that are plotted by changing idx such that it equals the indexes of the desired state variables as they appear in the data.\n\n\n\n\n\n","category":"method"},{"location":"modelanalysis/#UniversalDiffEq.phase_plane_3d-Tuple{UDE}-modelanalysis","page":"Model analysis","title":"UniversalDiffEq.phase_plane_3d","text":"phase_plane_3d(UDE::UDE; idx=[1,2,3], u1s=-5:0.25:5, u2s=-5:0.25:5, u3s=-5:0.25:5, T = 100)\n\nThe same as phase_plane(), but displays three dimensions/state variables instead of two.\n\n\n\n\n\n","category":"method"},{"location":"modelanalysis/","page":"Model analysis","title":"Model analysis","text":"UniversalDiffEq.forecast(UDE::UDE, u0::AbstractVector, times::AbstractVector)\nUniversalDiffEq.print_parameter_estimates(UDE::UDE)\nUniversalDiffEq.plot_forecast(UDE::UDE, T::Int)\nUniversalDiffEq.get_NN_parameters(UDE::UDE)\nUniversalDiffEq.get_parameters(UDE::UDE)","category":"page"},{"location":"modelanalysis/#UniversalDiffEq.forecast-Tuple{UDE, AbstractVector, AbstractVector}-modelanalysis","page":"Model analysis","title":"UniversalDiffEq.forecast","text":"forecast(UDE::UDE, u0::AbstractVector{}, times::AbstractVector{})\n\nPredictions from the trained UDE model starting at u0 and saving values at times. Assumes u0 is the value at initial time times[1]\n\n\n\n\n\n","category":"method"},{"location":"modelanalysis/#UniversalDiffEq.print_parameter_estimates-Tuple{UDE}-modelanalysis","page":"Model analysis","title":"UniversalDiffEq.print_parameter_estimates","text":"print_parameter_estimates(UDE::UDE)\n\nPrints the values of the known dynamics parameters estimated by the UDE model.\n\n\n\n\n\n","category":"method"},{"location":"modelanalysis/#UniversalDiffEq.plot_forecast-Tuple{UDE, Int64}-modelanalysis","page":"Model analysis","title":"UniversalDiffEq.plot_forecast","text":"plot_forecast(UDE::UDE, T::Int)\n\nPlots the model's forecast up to T time steps into the future from the last observation.\n\n\n\n\n\n","category":"method"},{"location":"modelanalysis/#UniversalDiffEq.get_NN_parameters-Tuple{UDE}-modelanalysis","page":"Model analysis","title":"UniversalDiffEq.get_NN_parameters","text":"get_NN_parameters(UDE::UDE)\n\nReturns the values of the weights and biases of the neural network.\n\n\n\n\n\n","category":"method"},{"location":"modelanalysis/#UniversalDiffEq.get_parameters-Tuple{UDE}-modelanalysis","page":"Model analysis","title":"UniversalDiffEq.get_parameters","text":"get_parameters(UDE::UDE)\n\nReturns model parameters.\n\n\n\n\n\n","category":"method"}]
}
