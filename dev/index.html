<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>UniversalDiffEq.jl · UniversalDiffEq.jl</title><meta name="title" content="UniversalDiffEq.jl · UniversalDiffEq.jl"/><meta property="og:title" content="UniversalDiffEq.jl · UniversalDiffEq.jl"/><meta property="twitter:title" content="UniversalDiffEq.jl · UniversalDiffEq.jl"/><meta name="description" content="Documentation for UniversalDiffEq.jl."/><meta property="og:description" content="Documentation for UniversalDiffEq.jl."/><meta property="twitter:description" content="Documentation for UniversalDiffEq.jl."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>UniversalDiffEq.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>UniversalDiffEq.jl</a><ul class="internal"><li><a class="tocitem" href="#Universal-dynamic-equations"><span>Universal dynamic equations</span></a></li><li><a class="tocitem" href="#How-UniversalDiffEq.jl-works"><span>How UniversalDiffEq.jl works</span></a></li><li><a class="tocitem" href="#Data-types"><span>Data types</span></a></li><li><a class="tocitem" href="#Package-contents"><span>Package contents</span></a></li></ul></li><li><a class="tocitem" href="Models/">Model Constructors</a></li><li><a class="tocitem" href="TrainingRoutines/">Training routines</a></li><li><a class="tocitem" href="ModelTesting/">Model performance</a></li><li><a class="tocitem" href="CrossValidation/">Cross validation</a></li><li><a class="tocitem" href="NutsAndBolts/">UDE model construction</a></li><li><a class="tocitem" href="MultipleTimeSeries/">Fitting a model to multiple time series</a></li><li><a class="tocitem" href="modelanalysis/">Model analysis</a></li><li><a class="tocitem" href="examples/">Examples</a></li><li><a class="tocitem" href="API/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>UniversalDiffEq.jl</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>UniversalDiffEq.jl</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/Jack-H-Buckner/UniversalDiffEq.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/Jack-H-Buckner/UniversalDiffEq.jl/blob/main/docs/src/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="UniversalDiffEq.jl"><a class="docs-heading-anchor" href="#UniversalDiffEq.jl">UniversalDiffEq.jl</a><a id="UniversalDiffEq.jl-1"></a><a class="docs-heading-anchor-permalink" href="#UniversalDiffEq.jl" title="Permalink"></a></h1><p>UniversalDiffEq.jl is a library for building universal dynamic equations (UDEs) and neural ordinary differential equations (NODEs). These models use neural networks to learn unknown nonlinear relationships from time series data. The package provides model constructor functions to build discrete and continuous time models that combine known parametric functions with unknown functions represented by neural networks. UniversalDiffEq.jl allows users to choose between several training routines to fit the to data, including state-space modeling procedures that increase the stability of the training routine on noisy and highly variable data sets. The package leverages the Julia scientific machine learning (SciML) ecosystem to build and train the models. The term &quot;universal&quot; comes from the <a href="https://en.wikipedia.org/wiki/Universal_approximation_theorem">universal approximation theorem</a>.</p><h2 id="Universal-dynamic-equations"><a class="docs-heading-anchor" href="#Universal-dynamic-equations">Universal dynamic equations</a><a id="Universal-dynamic-equations-1"></a><a class="docs-heading-anchor-permalink" href="#Universal-dynamic-equations" title="Permalink"></a></h2><p>Universal dynamic equations include two classes of models: universal differential equations and universal difference equations. Universal differential equations are continuous-time models that learn the right-hand side of a system of ordinary differential equations from time series data</p><p class="math-container">\[\frac{du}{dt} = f(u).\]</p><p>Universal difference equations are discrete-time models that learn the right-hand side of a system of difference equations</p><p class="math-container">\[u_{t+1} = u_{t} + f(u).\]</p><p>In the simplest case, a neural network <span>$NN$</span> represents the entire right-hand side of the model <span>$f(\mathbf{x}) = NN(\mathbf{x})$</span>. These models are sometimes called neural ordinary differential equations (NODEs). However, in general, the right-hand side of the model can include both neural networks and parametric functions. For example, the classic Lotka-Volterra predator-prey model includes a growth term for the prey <span>$rN$</span>, a mortality rate for the predator <span>$mP$</span>, and a linear interaction term between the two species <span>$\alpha NP$</span>. We can use universal differential equations to build a more flexible version of this model by replacing the linear interaction term with a neural network</p><p class="math-container">\[\frac{dN}{dt} = rN - NN(N,P)

\\

\frac{dP}{dt} = \theta NN(N,P) - mP.\]</p><p>We can train the neural network <span>$NN$</span> and estimate the biological parameters <span>$r$</span>, <span>$m$</span>, and <span>$\theta$</span> from time series data using the training routines defined in UniversalDiffEq.jl.</p><h2 id="How-UniversalDiffEq.jl-works"><a class="docs-heading-anchor" href="#How-UniversalDiffEq.jl-works">How UniversalDiffEq.jl works</a><a id="How-UniversalDiffEq.jl-works-1"></a><a class="docs-heading-anchor-permalink" href="#How-UniversalDiffEq.jl-works" title="Permalink"></a></h2><p>UniversalDiffEq.jl provides functions for four stages of analysis: model building, training, performance evaluation, and analysis. The package provides three main model constructor functions: <code>CustomDerivatives</code>, <code>CustomDifferences</code>, and <code>NODE</code>. <code>CustomDerivatives</code>, builds a universal differential equation based on a user-defined function that describes the right-hand side of a differential equation. <code>CustomDifferences</code> provides the same functionality for discrete-time models.<code>NODE</code> builds a neural ordinary differential equation and only requires a data set from the user (although it has additional key work arguments). Each of these functions has an equivalent with the prefix “Multi” (e.g. <code>MultiCustomDerivatives</code>) to build models for data sets that include multiple time series with similar dynamics. The following block of code shows how to build a UDE model that represents predatory prey interactions using the <code>CustomDerivatives</code> function.</p><pre><code class="language-julia hljs">using UniversalDiffEq, DataFrames


# Generate synthetic predator-prey data
data,plt = UniversalDiffEq.LotkaVolterra() 


# Build feed-forward neural network with two inputs and one output
NN,params = UniversalDiffEq.SimpleNeuralNetwork(2,1)


# Set model parameters estimating 
init_parameters = (NN = params, r = 0.1, k = 10.1, m = 0.1, theta = 0.1)


# Define right-hand side of the UDE model
function dudt(u,p,t)


   C = abs(NN(u,p.NN)[1]) # Calculate prey consumption rate with neural network
   r, k, theta, m = abs.([p.r, p.k, p.theta, p.m]) # transform model parameters to get positive values


   # Calculate rates of change for prey u[1] and predator u[2]
   dx1 = r*u[1]*(1-u[1]/k) - C
   dx2 = theta*C - m*u[2]


   return [dx1,dx2]
end

# Construct UDE model using the CustomDerivatives function
model = CustomDerivatives(data,dudt,init_parameters)</code></pre><p>The next step is fitting the model to the data using the <code>train!</code> function. The <code>train!</code> function builds a loss function for the model from the model structure and data sets provided by the user. It then runs an optimization algorithm to update the model parameters. The loss function and optimization algorithm used can be supplied using keyword arguments. The flowing block calls <code>train!</code> and specifies the derivative matching loss function and the ADAM gradient descent optimization algorithm. The different loss functions, optimization algorithms, and the remaining keyword arguments are discussed in detail on the “Training routines” page.  </p><pre><code class="language-julia hljs"># Use the train function to fit the model to the data
train!(model;  loss_function = &quot;derivative matching&quot;,
              optimizer = &quot;ADAM&quot;,
              regularization_weight = 0.0,
              verbose = false,
              loss_options = (d = 10, ),
              optim_options = (maxiter = 1000, step_size = 0.01))</code></pre><p>Two primary functions are provided to test the performance of the model on in sample data, <code>plot_predictions</code> and <code>plot_state_estimates.</code> Care should be taken when using these functions because their interpretation depends on the training procedure used to fit the models. Each training does two things: 1) updates the parameters of the UDE model to match the dynamics observed in the data set, and 2) estimates the value of the state variables, assuming the observation in the data set includes some observation error. The plot state estimates function compares the estimated state variables to the observations in the data set. In contrast, the plot predictions function compares the changes observed in the estimated state variables to those predicted by the UDE model.  </p><p>For example, the derivative matching algorithm used in this example first fits a smooth curve to the data set using a spline regression and then trains the model by comparing the derivatives of the smoothing curve to the derivatives of the UDE model. The plot state estimates function shows the predictions of the smoothing curve, while the plot predictions show how well the predictions made with the UDE match the smoothing curve. In this case, the smoothing curve fit by the derivative matching algorithm is a good fit to the data set. </p><pre><code class="language-julia hljs"># Compare the smoothing curve to the data 
plot_state_estimates(model)</code></pre><p>&lt;img alt=&quot;Lotka-Volterra Predictions&quot; width = &quot;500px&quot; src=&quot;figures/state_plot.png&quot; /&gt;</p><p>The one-step-ahead forecasts of the UDE model also match the changes in the estimated states quite set well. </p><pre><code class="language-julia hljs"># Compare predicted to observed changes
plot_predictions(model)</code></pre><p>&lt;img alt=&quot;Lotka-Volterra States&quot; width = &quot;500px&quot; src=&quot;figures/predictions_plot.png&quot; /&gt;</p><p>The performacne of the model on outof sample data can be estimated using leave future ot cross validation using the  <code>leave_future_out_cv</code> function. </p><p>Finally, the package includes several functions to analyze the dynamics predicted by the model. The simplest of these is the plot forecast function <code>plot_forecast</code>, which simulates the UDE model for a fixed number of time steps. The <code>get_right_hand_side</code> function allows the user to access the derivatives of the UDE model to analyze as you might any other differential equation model. Other more specific fuctions are also provided and documented in the API. </p><pre><code class="language-julia hljs"># plot forecast
p1, (p2,p3) = UniversalDiffEq.plot_forecast(model, 50)
p1</code></pre><p>&lt;img alt=&quot;Lotka-Volterra States&quot; width = &quot;500px&quot; src=&quot;figures/forecast_plot.png&quot; /&gt;</p><h2 id="Data-types"><a class="docs-heading-anchor" href="#Data-types">Data types</a><a id="Data-types-1"></a><a class="docs-heading-anchor-permalink" href="#Data-types" title="Permalink"></a></h2><p>UniversalDiffEq.jl can train models on individual time series <span>$y_t$</span> or multiple time series <span>$y_{i,t}$</span> from systems with similar dynamics. Separate model constructors are provided for models trained on single and multiple time series. UniversalDiffEq.jl allows the models trained on multiple time series to include parameters that have different values for each time series in the training set.</p><p>UniversalDiffEq.jl can accommodate irregularly sampled data. Data for continuous-time models can be sampled at any point in time, while discrete-time models require integer-valued time steps between observations. UniversalDiffEq.jl does not accommodate observations that are missing a subset of the state variables. In these cases, data imputation is necessary.</p><p>Models built with UniversalDiffEq.jl can incorporate covariates <span>$X_t$</span> that influence the dynamics of the primary state variables. Discrete-time models require the observations of the covariates to match the time when the state variables were observed.</p><h2 id="Package-contents"><a class="docs-heading-anchor" href="#Package-contents">Package contents</a><a id="Package-contents-1"></a><a class="docs-heading-anchor-permalink" href="#Package-contents" title="Permalink"></a></h2><ul><li><a href="Models/#Model-Constructors">Model Constructors</a></li><li class="no-marker"><ul><li><a href="Models/#NODEs-(i.e.,-nonparametric-universal-dynamic-equations)">NODEs (i.e., nonparametric universal dynamic equations)</a></li><li><a href="Models/#Customizing-universal-dynamic-equations">Customizing universal dynamic equations</a></li><li><a href="Models/#Adding-covariates">Adding covariates</a></li><li><a href="Models/#Adding-prior-information">Adding prior information</a></li></ul></li><li><a href="TrainingRoutines/#Training-routines">Training routines</a></li><li class="no-marker"><ul><li><a href="TrainingRoutines/#Gradient-matching-loss-function">Gradient matching loss function</a></li><li><a href="TrainingRoutines/#State-space-loss-functions">State-space loss functions</a></li><li><a href="TrainingRoutines/#Shooting-loss-function">Shooting loss function</a></li><li><a href="TrainingRoutines/#Multiple-shooting-loss-function">Multiple shooting loss function</a></li><li><a href="TrainingRoutines/#ADAM-optimizer">ADAM optimizer</a></li><li><a href="TrainingRoutines/#BFGS-optimizer">BFGS optimizer</a></li></ul></li><li><a href="MultipleTimeSeries/#Fitting-a-model-to-multiple-time-series">Fitting a model to multiple time series</a></li><li class="no-marker"><ul><li><a href="MultipleTimeSeries/#Multiple-time-series-custom-models">Multiple time series custom models</a></li></ul></li><li><a href="ModelTesting/#Model-performance">Model performance</a></li><li class="no-marker"><ul><li><a href="ModelTesting/#Evaluating-model-fits-to-training-data">Evaluating model fits to training data</a></li><li><a href="ModelTesting/#Model-forecasting-with-testing-data">Model forecasting with testing data</a></li></ul></li><li><a href="CrossValidation/#Cross-validation">Cross validation</a></li><li class="no-marker"><ul><li><a href="CrossValidation/#doc-string">doc string</a></li><li><a href="CrossValidation/#Minimal-example">Minimal example</a></li></ul></li><li><a href="NutsAndBolts/#UDE-model-construction">UDE model construction</a></li><li><a href="modelanalysis/#Model-analysis">Model analysis</a></li><li><a href="examples/#Examples">Examples</a></li><li class="no-marker"><ul><li><a href="examples/#Using-time-dependent-NODEs-to-predict-regime-shifts">Using time-dependent NODEs to predict regime shifts</a></li><li><a href="examples/#Using-UDEs-to-learn-the-dynamics-of-coupled-human-natural-systems">Using UDEs to learn the dynamics of coupled human-natural systems</a></li></ul></li><li><a href="API/#API">API</a></li></ul></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="Models/">Model Constructors »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.3.0 on <span class="colophon-date" title="Thursday 23 October 2025 15:02">Thursday 23 October 2025</span>. Using Julia version 1.10.10.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
